#+TITLE: Alex Birdsall's doom emacs config
#+PROPERTY: header-args :noweb yes

This is my doom config. It's a literate config, so the code snippets are living documentation; they
get exported to specific init files.

At present, this /almost/ only tangles to elisp files for doom emacs to load; it also builds ~/.guile

#+begin_src elisp :tangle packages.el
<<packages-preamble>>
#+end_src
#+begin_src elisp
<<config-preamble>>
#+end_src

* work nicely with the surrounding computer
** clipboard
By default, editing stuff in emacs shouldn't pollute the system clipboard:
#+begin_src elisp
(setq! select-enable-clipboard nil)

#+end_src

Pasting from the system clipboard should be easy:
#+begin_src elisp
(map! "C-M-y" #'clipboard-yank)

#+end_src

And capturing text to it should be, too. To write this, I just copy-pasted the actual source of ~evil-yank~
and added ~select-enable-clipboard~ and ~select-enable-primary~ to the ~let~ form around the
logic:
#+begin_src elisp
(evil-define-operator evil-yank-to-clipboard (beg end type register yank-handler)
  "Save the characters in motion into the kill-ring."
  :move-point nil
  :repeat nil
  (interactive "<R><x><y>")
  (let ((evil-was-yanked-without-register
         (and evil-was-yanked-without-register (not register)))
        (select-enable-clipboard t)
        (select-enable-primary t))
    (cond
     ((and (fboundp 'cua--global-mark-active)
           (fboundp 'cua-copy-region-to-global-mark)
           (cua--global-mark-active))
      (cua-copy-region-to-global-mark beg end))
     ((eq type 'block)
      (evil-yank-rectangle beg end register yank-handler))
     ((memq type '(line screen-line))
      (evil-yank-lines beg end register yank-handler))
     (t
      (evil-yank-characters beg end register yank-handler)
      (goto-char beg)))))

(map! :map evil-normal-state-map "Y" #'evil-yank-to-clipboard)
(map! :map evil-motion-state-map "Y" #'evil-yank-to-clipboard)

#+end_src

Those are great for interactive use; now let's make programmatically adding text to the
system clipboard nice and easy, too:
#+begin_src elisp
(defun copy-to-clipboard (string)
  "Copies `STRING' to the system clipboard and the kill ring. When called interactively,
the active region will be used."
  (interactive
   (when (region-active-p)
     (list (buffer-substring-no-properties (region-beginning) (region-end)))))
  (let ((select-enable-clipboard t)
        (select-enable-primary t))
    (kill-new string)))

#+end_src

This one is just for funsies:
#+begin_src elisp
(defun copy-unicode-char-to-clipboard ()
  "Interactively select a unicode character and copy it to the system clipboard."
  (interactive)
  (with-temp-buffer
    (call-interactively #'insert-char)
    (let ((char (buffer-string)))
      (copy-to-clipboard char)
      (message "%s" (concat "Copied " char " to system clipboard")))))

#+end_src

** macOS shenanigans
this config [[https://en.wikipedia.org/wiki/Unitarian_Universalist_Association#Principles_and_purposes][covenants to affirm and promote the inherent worth and dignity]] of every computer it's installed on, even macs
I was raised by and around a bunch of earnest, wordy people; deal with it.

#+begin_src elisp
(setq! mac-command-modifier 'meta
       mac-option-modifier 'meta
       ns-function-modifier 'super)
#+end_src

*** trouble? shoot it.
Sometimes on macOS, emacs will throw a constant stream of errors that end with "Too many open files" all over itself. The solution, per [[https://www.blogbyben.com/2022/05/gotcha-emacs-on-mac-os-too-many-files.html][this blog post]]?
#+begin_src elisp :tangle no
(file-notify-rm-all-watches)
#+end_src

Also, I have had certain macOS computers on which emacs consistently has a misdefined
~woman-manpath~, which is weird! Particularly since ~(describe-variable 'woman-manpath)~
will report a functioning, correct-looking original value. If this hits you, you'll need
to reset the value in =~/.config/doom/local.el= so it's manually set correctly. Or rerun
~doom env~ on the command line in a context where ~MANPATH~ is correct. Here is a minimal
(i.e. with all nonstandard and/or versioned paths from language-specific package manager
installation locations removed) reference version:
#+begin_src elisp :tangle no
(setq! woman-manpath
       '("/opt/homebrew/share/man/"
         "/usr/share/man/"
         "/usr/local/share/man/"
         "/usr/share/man"
         "/usr/local/share/man"
         "/usr/X11/man"
         "/Library/Apple/usr/share/man"))
#+end_src

** better terminal keycode handling
Leaving the untangled manual config in place for a bit so things work with my computers
which aren't running a super up-to-date version of doom.

Relatedly, leaving this in ~packages.el~ so I can just dump the activation code in ~local.el~ if needed.
#+begin_src elisp :tangle packages.el
(package! kkp)
#+end_src

The naive config (for why it's disabled see immediately below):
#+begin_src elisp :tangle no
(use-package! kkp
  :config (global-kkp-mode +1))
#+end_src

The following snipped was added as a test at Henrik's request; it does what I want, and
presumably somehow is better optimized for doom's loading than the above.
#+begin_src elisp tangle no
(add-hook! 'tty-setup-hook :depth -90
  (defun +tty-init-kkp-h ()
    (global-kkp-mode +1)
    (kkp-enable-in-terminal)))
#+end_src
* text editing per se
** text manipulation utilities [0/1]
See the =text manipulation utility macros= appendix for deets.
#+begin_src elisp
<<text-manipulation-metafns>>
#+end_src
*** ~(not-every programming_language({conventionallyUses: "THE_SAME_CASING"}))~
Let's make some helper commands for manipulating the casing of programming symbols. Since
they are defined with ~def-text-transform~, they're usable as elisp string utilities and as
a command on region both.
#+begin_src elisp
(def-text-transform 'kebab-case #'s-dashed-words)
(def-text-transform 'pascal-case #'s-upper-camel-case)
(def-text-transform 'camel-case #'s-lower-camel-case)
(def-text-transform 'snake-case #'s-snake-case)
(def-text-transform 'screaming-snake-case #'(lambda (str) (s-upcase (s-snake-case str))))
(def-text-transform 'lower-words-case #'(lambda (str) (s-join " " (-map #'s-downcase (s-split-words str)))))
#+end_src

*** manipulate numbers at point
#+begin_src elisp
(defun decrement-number-at-point ()
  "Decrement the number at point by 1."
  (interactive)
  (save-excursion
    (skip-chars-backward "0-9")
    (when (looking-at "[0-9]+")
      (let ((num (string-to-number (match-string 0))))
        (replace-match (number-to-string (1- num)))))))

(defun increment-number-at-point ()
  "Increment the number at point by 1."
  (interactive)
  (save-excursion
    (skip-chars-backward "0-9")
    (when (looking-at "[0-9]+")
      (let ((num (string-to-number (match-string 0))))
        (replace-match (number-to-string (1+ num)))))))

(map! :leader
      :desc "decrement at point" "nj" #'decrement-number-at-point
      :desc "increment at point" "nk" #'increment-number-at-point)
#+end_src
** completion
*** built-in completions
Might as well use the more powerful built-in expansion system:
#+begin_src elisp
(map! [remap dabbrev-expand] #'hippie-expand)
#+end_src

*** company-mode
Turns out, I get extremely annoyed when emacs lags because ispell is second-guessing my
writing the english language!
#+begin_src elisp
(setq company-global-modes '(not text-mode org-mode))
#+end_src

** an opinionated mix of the vim and emacs keybinding schemes [0/3]
*** TODO make the long-threatened PR adding a ~+hybrid~ flag to the evil module
This was my first draft, which I think... mostly worked?
#+begin_src diff :tangle no
diff --git a/modules/editor/evil/config.el b/modules/editor/evil/config.el
index db274fab2..344ccf8c0 100644
--- a/modules/editor/evil/config.el
+++ b/modules/editor/evil/config.el
@@ -420,6 +420,9 @@ directives. By default, this only recognizes C directives.")
     "#" #'evil-visualstar/begin-search-backward))


+(when (modulep! +hybrid)
+  (setq! evil-disable-insert-state-bindings t))
+
 ;;
 ;;; Text object plugins

diff --git a/modules/lang/markdown/config.el b/modules/lang/markdown/config.el
index 6602d1339..4bec4c332 100644
--- a/modules/lang/markdown/config.el
+++ b/modules/lang/markdown/config.el
@@ -137,7 +137,8 @@ capture, the end position, and the output buffer.")
         :n "TAB" #'markdown-cycle
         :n [backtab] #'markdown-shifttab
         :i "M-*" #'markdown-insert-list-item
-        :i "M-b" #'markdown-insert-bold
+        (:when (not (modulep! :editor evil +hybrid)) :i "M-b" #'markdown-insert-bold)
+        (:when (modulep! :editor evil +hybrid) :i "M-B" #'markdown-insert-bold)
         :i "M-i" #'markdown-insert-italic
         :i "M-`" #'+markdown/insert-del
         :i "M--" #'markdown-insert-hr
#+end_src

**** TODO are there (still?) load-order problems when running ~(setq! evil-disable-insert-state-bindings t)~ at a normal time (i.e. not hella early)?
I recall (now too vaguely smh) that it only has worked for me when I put that (in a vanilla ~setq~ form) in ~init.el~, but not in ~config.el~. Why?

*** [DEPRECATED] wait, is this split two tmux panes or two emacs windows?
+WHO CARES+

So this used to be my JAM (I mean, just note the account hosting that fork's repo), but
increased usage of vanilla emacs bindings, both in emacs and zsh, eventually lead me to
prefer having =C-k= as ~kill-line~ to having a universal, super-accessible binding for
navigating up a split in all my various terminal contexts. Pour one out, we had a good run.

#+begin_src elisp :tangle no
(package! evil-tmux-navigator
  :recipe (:host github :repo "ambirdsall/evil-tmux-navigator"))
(unpin! evil-tmux-navigator)
#+end_src

#+begin_src elisp :tangle no
(use-package! evil-tmux-navigator
  :config (evil-tmux-navigator-bind-keys))
#+end_src

Now, all elegies aside, I do semi-frequently use my tmux split navigation command (now
=prefix+{h,j,k,l}= rather than =ctrl+{h,j,k,l}=) when I intend to navigate a TUI emacs split.
It would be good to revisit the package in a way that makes it workable with my current
keybinding scheme as well sometime.
*** replace with register
#+begin_src elisp :tangle packages.el
(package! evil-replace-with-register)
#+end_src

#+begin_src elisp
(use-package! evil-replace-with-register
  :init
  (setq evil-replace-with-register-key (kbd "gr"))
  :config (evil-replace-with-register-install))
#+end_src
*** evil-exchange
#+begin_src elisp :tangle packages.el
(package! evil-exchange)
#+end_src

#+begin_src elisp
(use-package! evil-exchange
  :config (evil-exchange-install))
#+end_src
*** matchit
#+begin_src elisp :tangle packages.el
(package! evil-matchit)
#+end_src

#+begin_src elisp
(use-package! evil-matchit
  :config (global-evil-matchit-mode 1))
#+end_src
*** changing up some default settings
#+begin_src elisp
(setq! evil-ex-search-persistent-highlight nil
       +evil-want-o/O-to-continue-comments nil)
#+end_src

You can have my ~evil-substitute~ when you pry it from my cold, dead fingers.
#+begin_src elisp :tangle packages.el
(package! evil-snipe :disable t)
#+end_src

*** imenu
I much prefer evil's indentation command set, making the default ~M-i~ binding,
~tab-to-tab-stop~, a rather poor use of prime real estate. I would be much better served
using it as a mnemonic binding for ~imenu~:
#+begin_src elisp
(map! :after consult "M-i" #'consult-imenu)
#+end_src

*** TODO jump into/around a visual selection
=SPC v= is (or was, at time of writing) not a default binding in [[file:~/.emacs.d/modules/config/default/+evil-bindings.el][doom's default evil bindings]]; that seems like a potential oversight.

- If region is not active, works like vim's =gv=
- else, DWIM selection changes
  + cycle through structural selectors?
    - if tree mode is available?
  + that "expand visual selection" package
  + ?

** text objects
#+begin_src elisp
;; this macro was copied from someone who copied it from here: https://stackoverflow.com/a/22418983/4921402
(after! evil
  (defmacro define-and-bind-quoted-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))
  (define-and-bind-quoted-text-object "dollar" "$" "\\$" "\\$")
  (define-and-bind-quoted-text-object "pipe" "|" "|" "|")
  (define-and-bind-quoted-text-object "slash" "/" "/" "/")
  (define-and-bind-quoted-text-object "space" " " " " " ")
  (define-and-bind-quoted-text-object "tilda" "~" "~" "~")
  (define-and-bind-quoted-text-object "asterisk" "*" "*" "*"))
#+end_src
*** line text object
#+begin_src elisp :tangle packages.el
(package! evil-textobj-line
  :recipe (:host github :repo "emacsorphanage/evil-textobj-line"))
#+end_src

#+begin_src elisp
(use-package! evil-textobj-line
  :after evil)
#+end_src
* buffers, windows, frames, workspaces... all that emacs shit [0/5]
** window navigation
*** hydra at =SPC w.=
#+begin_src elisp
(defhydra amb/window-nav-hydra (:hint nil :exit nil)
  "
Navigate Windows (exit with RET, ESC, q, or C-g)
  ^Navigate^
  _h_ ←  _j_ ↓  _k_ ↑  _l_ →

  ^Rearrange^
  _H_ ←  _J_ ↓  _K_ ↑  _L_ →
  _x_ Close _s_/_v_ Split

  ^Repurpose^
  _._ Nearby file  _p_/_SPC_ Project file  _r_ Recent file
"
  ;; Navigation
  ("h" evil-window-left)
  ("j" evil-window-down)
  ("k" evil-window-up)
  ("l" evil-window-right)

  ;; Move windows
  ("H" +evil/window-move-left)
  ("J" +evil/window-move-down)
  ("K" +evil/window-move-up)
  ("L" +evil/window-move-right)

  ;; Act on windows
  ("x" +workspace/close-window-or-workspace)
  ("." find-file)
  ("p" projectile-find-file)
  ("SPC" projectile-find-file)
  ("r" consult-recent-file)
  ("s" evil-window-split)
  ("v" evil-window-vsplit)

  ;; Exit hydra
  ("RET" nil :exit t)
  ("ESC" nil :exit t)
  ("q" nil :exit t)
  ("C-g" nil :exit t))

(map! :leader
      :desc "get movin'" "w." #'amb/window-nav-hydra/body)
#+end_src

*** ace-window
#+begin_src elisp :tangle packages.el
(package! ace-window)
#+end_src

#+begin_src elisp

(use-package! ace-window
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-scope 'frame
        aw-dispatch-always 't
        aw-dispatch-alist '((?x aw-delete-window "Delete Window")
                            (?m aw-swap-window "Swap Windows")
                            (?M aw-move-window "Move Window")
                            (?c aw-copy-window "Copy Window")
                            (?b aw-switch-buffer-in-window "Select Buffer")
                            (?B aw-switch-buffer-other-window "Switch Buffer Other Window")
                            (?n aw-flip-window)
                            (?c aw-split-window-fair "Split Fair Window")
                            (?v aw-split-window-vert "Split Vert Window")
                            (?z aw-split-window-horz "Split Horz Window")
                            (?o delete-other-windows "Delete Other Windows")
                            (?? aw-show-dispatch-help)))
  (map! :leader "ww" #'ace-window))
#+end_src
** files, both local and remote
*** oops, I need to ~sudo~ edit this file
#+begin_src elisp
(defun sudo ()
  "Use TRAMP to `sudo' the current buffer."
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+end_src
*** copy a filepath from the project root
#+begin_src elisp
(after! projectile
  (defun yank-buffer-filename-relative-to-project ()
    "Copy the current buffer's path, relative to the project root, to the kill ring."
    (interactive)
    (if-let (filename (or buffer-file-name (bound-and-true-p list-buffers-directory)))
        (message (kill-new (f-relative filename (projectile-acquire-root))))
      (error "Couldn't find filename in current buffer")))

  (map! :leader "fY" #'yank-buffer-filename-relative-to-project))

#+end_src

*** jump to arbitrary files in specific projects/directories from anywhere
#+begin_src elisp
(after! projectile
  (defmacro file-jumper-for-project (project-root)
    "Defines an anonymous interactive function for picking an arbitrary file from the given PROJECT-ROOT.

Conveniently, by explicitly providing the project root, you can use the conveniently
flattened file hierarchy generated by `projectile-project-files' regardless of whether
projectile would recognize your root directory as a project."
    `(cmd! (find-file (string-join
                       (list
                        ,project-root
                        (projectile-completing-read "Find file: " (projectile-project-files ,project-root)))
                       "/"))))

  (map! :leader
        :desc "Browse dotfiles" "f." (cmd! (find-file
                                         (completing-read "Open dotfile: "
                                                          (split-string (shell-command-to-string "dots ls-files ~") "\n"))))
        :desc "Take me $HOME, country roads" "f~" (cmd! (+vertico/find-file-in "~/"))
        :prefix ("fj" . "Jump into specific projects")
        :desc "Browse ~/.config/" :ne "c" (file-jumper-for-project "~/.config/")
        :desc "Browse ~/bin/" :ne "b" (file-jumper-for-project "~/bin/")))
#+end_src
** scratch buffer
If they're in org, that's good for notes and I can still write/exec code
#+begin_src elisp
(setq! doom-scratch-initial-major-mode 'org-mode)
#+end_src

** don't automatically open a new workspace for each new emacsclient frame
I like freely opening client instances in the terminal and desktop environment alike; when
doing so, a 1:1 mapping with workspaces quickly creates a terrible clutter.
#+begin_src elisp
(after! persp-mode (setq! persp-emacsclient-init-frame-behaviour-override -1))
#+end_src

** Don't confirm before quitting
I said what I said.
#+begin_src elisp
(setq confirm-kill-emacs nil)
#+end_src
** appearance
*** splash screen [0/1]
For additional reference, see [[https://discourse.doomemacs.org/t/how-to-change-your-splash-screen/57][this doom discourse post]].

**** make it look nice
I don't rely on the short menu anymore; I know how to get around in doom/emacs just fine now. Let's get rid of that. And while we're at it, let's replace the splash image with something nice:
#+begin_src elisp
(setq fancy-splash-image (concat doom-private-dir "emacs.png"))
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-footer)
#+end_src

**** TODO make it super useful
Hat tip to [[https://tecosaur.github.io/emacs-config/config.html#dashboard-quick-actions][tecosaur's config]], whence much of this came. First off, let's make it easy to
open the dashboard:
#+begin_src elisp :tangle no
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

Teco adds some additional code to clean
up the appearance of the dashboard; this could use some similar TLC as a follow-up.

*For now, this is disabled (via ~:tangle no~); despite the bindings being tagged with ~:ne~,
they are, in practice, only being added to the emacs-state map.*

#+begin_src elisp :tangle no
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Previous buffer" :ne "p" #'previous-buffer
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

*** typography [0/1]
**** fonts
On arch linux, here are the packages you'll want to download:
- =ttf-fira-code=
- =otf-overpass=
- =ttc-iosevka=
- =ttc-iosevka-slab=

Fira Code is
#+begin_src elisp
(setq doom-font-increment 1
      doom-font (font-spec :family "Fira Code" :size (if IS-MAC 13 16) :style "Retina" :weight 'semi-bold)
      ;; doom-font (font-spec :family "Iosevka Fixed Slab" :size 16 :weight 'medium)
      doom-big-font (font-spec :family "Fira Code" :size (if IS-MAC 20 26))
      doom-variable-pitch-font (font-spec :family "Overpass" :size (if IS-MAC 15 20))
      doom-serif-font (font-spec :family "Iosevka Slab" :size (if IS-MAC 13 16))
      doom-unicode-font (font-spec :family "Iosevka" :size (if IS-MAC 13 16)))
#+end_src
We’d like to use mixed pitch in certain modes. If we simply add a hook, when directly
opening a file with (a new) Emacs, ~mixed-pitch-mode~ runs before UI initialisation, which is
problematic. To resolve this, we create a hook that runs after UI initialisation and both
- conditionally enables ~mixed-pitch-mode~
- sets up the mixed pitch hooks
#+begin_src elisp
(defvar mixed-pitch-modes '(org-mode markdown-mode gfm-mode Info-mode text-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

Additionally, there are emojis:
#+begin_src elisp :tangle packages.el
(package! emojify)
#+end_src

**** TODO try out [[https://www.reddit.com/r/emacs/comments/shzif1/n%CE%BBno_font_stack/][NANO emacs font stack]]
I mean, it's nice.

**** whitespace
#+begin_src elisp
(whitespace-mode 1)
#+end_src
*** theme this bad boy [0/1]
I should really wrap all theme config in a single ~(unless noninteractive <theme config>)~ form and =noweb= in the different logical sections
**** that said...
***** Define a theme switcher utility [0/1]
Sometimes (usually) I want dark mode; sometimes (presenting, in direct sunlight, or just
mixing it up) I want light mode. What I do /not/ want is to have to pick a specific theme
out of a haystack by name each time I want to toggle between light and dark; give me
instead the blithe simplicity of a lightswitch flipped in passing. Or rather, let me give
it to myself, so I can flit over to a different light and/or dark theme at my pleasure:
#+begin_src elisp
(unless noninteractive
  (setq
   amb/doom-dark-theme 'doom-one
   amb/doom-light-theme 'doom-one-light)

  (defun amb/toggle-themes ()
    "Cycle through a set of predefined themes according to whatever unholy logic is currently residing in its inner `cond' form."
    (interactive)
    (cond ((eq doom-theme amb/doom-dark-theme) (load-theme amb/doom-light-theme))
          (t (load-theme amb/doom-dark-theme))))

  (map! :leader
        "tt" #'amb/toggle-themes)

  (load-theme amb/doom-dark-theme t))
#+end_src


****** TODO use a ring instead of imperatively toggling btw hardcoded vars
- [ ] look up rings in elisp manual lol
- [ ] create a container var that is, you guessed it,,,
- [ ] iterate through that in ~amb/toggle-themes~

***** [legacy] modus themes config
The modus themes (included with emacs since version twenty-eight point something) are a
thoughtfully-designed, goal-oriented set of color themes, designed for accessibility and
readability (high-contrast, anti-deuteranopic variants) and sporting delightfully-paired
names:
- /modus operandi/ :: Mode, or manner, of that which is to be worked. The light color theme, for one's toil under the sun.
- /modus vivendi/ :: Mode, or manner, of living. The dark color theme, for one's toil under monitor glare.

I don't use either one anymore—I appreciate their philosophical bent, but the extra
marginal config required to get them as cute as a nice choice out of ~doom-themes~ is hard
to justify. The real turning point, though, was discovering that when using tty emacs,
~modus-operandi~'s usage of colors from the terminal color theme meant that switching both
emacs and the surrounding terminal emulator to a light theme (as when working outside on a
sunny day) made the primary text face a unreadable.[fn:1]

Speaking of toggling switches, the modus themes expose quite a few semantically-named
variables for users to tweak; let's do so.

By default, as of writing, ~modus-vivendi~ uses a background color of ~#000000~ and text color
of ~#ffffff~. This pairing provides a /glaring/ degree of contrast; while that's in line with
the stated goals of the themes, let's tone it down just a touch. A touch of blue gives the
background a subtle "night sky" vibe; a touch of red makes the foreground text warmer.
We'll also want a corresponding adjustment to the background color of highlighted (i.e.
current) lines.

#+begin_src elisp :tangle no
(unless noninteractive
  (require-theme 'modus-themes)

  (setq modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-syntax (list 'alt-syntax 'yellow-comments)
        modus-themes-vivendi-color-overrides
        '((bg-main . "#0d0b11")
          (fg-main . "#ffeeee")
          (bg-hl-line . "#29272f"))
        modus-themes-operandi-color-overrides
        '((bg-hl-line . "#eeeeee"))))
#+end_src

*** line numbers
This determines the style of line numbers in effect. The options:
- ~t~ :: lines are numbered by which line they are in the file
- ~relative~ :: lines numbered by distance from current line in the file
- ~visual~ :: lines numbered by distance from current line on screen
- ~nil~ :: lines aren't numbered

I like absolute line numbers occasionally, and always when pairing/screen sharing. I like relative line numbers whenever I'm doing vim-style navigation. Turns out there's a way to get some of each:
#+begin_src elisp
(setq display-line-numbers-type 't)

(after! evil
  (add-hook! '(evil-operator-state-entry-hook evil-visual-state-entry-hook)
    (setq display-line-numbers 'relative))

  (add-hook! '(evil-operator-state-exit-hook evil-visual-state-exit-hook)
    (setq display-line-numbers 't)))
#+end_src
*** long lines: don't do 'em
#+begin_src elisp
(setq! fill-column 90)
(global-visual-line-mode -1)
#+end_src
*** Window title
I’d like to have just the buffer name, then if applicable the project folder

#+begin_src elisp
(setq frame-title-format
      '(""
        (:eval
         (if-let ((workspace-name (safe-persp-name (get-current-persp))))
           (format "%s ⋮ " workspace-name)))
        (:eval
         (let ((project-name (projectile-project-name))
               (workspace-name (safe-persp-name (get-current-persp))))
           (unless (or (string= "-" project-name) (string= workspace-name project-name))
             (format (if (buffer-modified-p)  " ◉ %s / " " %s / ") project-name))))
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))))
#+end_src


For example when I open my config file it the window will be titled config.org ● doom then as soon as I make a change it will become config.org ◉ doom.
*** tab bar :: display workspaces [0/2]
Taken from [[https://discourse.doomemacs.org/t/permanently-display-workspaces-in-the-tab-bar/4088][hylo's discourse post]], thanks hylo.

Notably, clicking on the tabs accomplishes nothing helpful with this setup.
#+begin_src elisp
(custom-set-faces!
  '(+workspace-tab-face :inherit default :family "Overpass" :height 135)
  '(+workspace-tab-selected-face :inherit (highlight +workspace-tab-face)))

(defvar amb/enable-workspace-tabs nil
  "Do I really want to show tabs of the workspace names? Tell me via this variable.")

(after! persp-mode
  (defun workspaces-formatted ()
    ;; fancy version as in screenshot
    (+doom-dashboard--center (frame-width)
                             (let ((names (or persp-names-cache nil))
                                   (current-name (safe-persp-name (get-current-persp))))
                               (mapconcat
                                #'identity
                                (cl-loop for name in names
                                         for i to (length names)
                                         collect
                                         (concat (propertize (format " %d" (1+ i)) 'face
                                                             `(:inherit ,(if (equal current-name name)
                                                                             '+workspace-tab-selected-face
                                                                           '+workspace-tab-face)
                                                               :weight bold))
                                                 (propertize (format " %s " name) 'face
                                                             (if (equal current-name name)
                                                                 '+workspace-tab-selected-face
                                                               '+workspace-tab-face))))
                                " "))))
  (defun amb/invisible-current-workspace ()
    "The tab bar doesn't update when only faces change (i.e. the
current workspace), so we invisibly print the current workspace
name as well to trigger updates"
    (propertize (safe-persp-name (get-current-persp)) 'invisible t))

  (customize-set-variable 'tab-bar-format '(workspaces-formatted tab-bar-format-align-right amb/invisible-current-workspace))

  ;; don't show current workspaces when we switch, since we always see them
  (advice-add #'+workspace/display :override #'ignore)
  ;; same for renaming and deleting (and saving, but oh well)
  (advice-add #'+workspace-message :override #'ignore)

  ;; need to run this later for it to not break frame size for some reason
  (run-at-time
   nil
   nil
   (cmd!
    (when amb/enable-workspace-tabs
      (tab-bar-history-mode)
      (tab-bar-mode +1)))))

#+end_src

This one is no better, but it /is/ simpler. Perhaps it's a better starting point for making a clickable version?
#+begin_src elisp :tangle no
(after! persp-mode
  ;; alternative, non-fancy version which only centers the output of +workspace--tabline
  (defun workspaces-formatted ()
    (+doom-dashboard--center (frame-width) (+workspace--tabline)))

  (defun hy/invisible-current-workspace ()
    "The tab bar doesn't update when only faces change (i.e. the
current workspace), so we invisibly print the current workspace
name as well to trigger updates"
    (propertize (safe-persp-name (get-current-persp)) 'invisible t))

  (customize-set-variable 'tab-bar-format '(workspaces-formatted tab-bar-format-align-right hy/invisible-current-workspace))

  ;; don't show current workspaces when we switch, since we always see them
  (advice-add #'+workspace/display :override #'ignore)
  ;; same for renaming and deleting (and saving, but oh well)
  (advice-add #'+workspace-message :override #'ignore))

;; need to run this later for it to not break frame size for some reason
(run-at-time nil nil (cmd! (tab-bar-mode +1)))
#+end_src

Having made this nice tab bar, we need a way to toggle it: some modes (notably PDFView)
have rendering logic that doesn't play nicely with (or is not properly aware of) the tab
bar.

#+begin_src elisp
(map! :leader
      :desc "toggle tab bar" "tT" #'tab-bar-mode)
#+end_src

**** TODO Mouse click bindings for the tab bar
A normal click on a tab navigates to it (optionally, if not the current one). Right clicking brings up a menu of nice things to be able to do.

**** TODO PDFView mode does not take tab bar height into account when rendering a page
The end result is having to scroll a small amount whenever I (\*Bob Seger voice*) turn the
page, which is frankly a bit annoying. A shitty workaround is to manually toggle, I guess.
*** window sizing
This is a nice little thing:
#+begin_src elisp :tangle packages.el
(package! golden-ratio)
#+end_src

It's automatic resizing behavior is overkill, but it's nice to be able to easily opt-in:
#+begin_src elisp
(use-package! golden-ratio
  :config
  (map! :leader "wG" #'golden-ratio))
#+end_src

So. Sometimes the current window just needs to be a little more. Let's make that situation nice and easy to handle:
#+begin_src elisp
(defvar amb--more-current-window-original-sizes (make-hash-table :test 'eq)
  "A hash table storing the original sizes of windows so they can be restored by `amb/more-current-window'.")

(defun amb--more-current-window-save-original-size (win)
  "Ensure the window configuration relative to a window object `WIN' is stored.
Window sizes are stored in `amb--more-current-window-original-sizes'."
  (unless (gethash win amb--more-current-window-original-sizes)
    (puthash win (current-window-configuration) amb--more-current-window-original-sizes)))

(defun amb/more-current-window ()
  "Make the current window larger based on predefined breakpoints.
If the window occupies the entire frame, restore its original size."
  (interactive)
  (let* ((win (selected-window))
         (frame-width (frame-width))
         (window-width (window-total-width win)))
    (cond
     ;; If the window is maximized, restore its original size.
     ((and (window-full-width-p win) (window-full-height-p win))
      (message "there and, uh,")
      (when-let ((orig-size (gethash win amb--more-current-window-original-sizes)))
        (message "and back again")
        (set-window-configuration orig-size)
        (remhash win amb--more-current-window-original-sizes)))
     ;; If the width is less than 50% of the frame, increase it to 50%.
     ;; Yes, I compare against 48%, not 50%; I don't want to be stuck at 50% when I want *more*
     ((< (/ (float window-width) frame-width) 0.48)
      (message "fiddy")
      (amb--more-current-window-save-original-size win)
      (let ((target-width (floor (* 0.50 frame-width))))
        (adjust-window-trailing-edge win (- target-width window-width) t)))
     ;; If the width is less than 61% of the frame, use golden-ratio.
     ((< (/ (float window-width) frame-width) 0.61)
      (message "goldy")
      (amb--more-current-window-save-original-size win)
      (call-interactively #'golden-ratio))
     ;; If the width is less than 70%, enlarge the window.
     ((< (/ (float window-width) frame-width) 0.70)
      (message "biggie")
      (amb--more-current-window-save-original-size win)
      (doom/window-enlargen))
     ;; Otherwise, maximize the window.
     (t
      (message "all that and then some")
      (amb--more-current-window-save-original-size win)
      (doom/window-maximize-buffer)))))

;; Bind the command to the leader key.
(map! :leader
      :desc "more of current window"
      "wM" #'amb/more-current-window)
#+end_src

* programming
** Indent however you wish, as long as you do it right
#+begin_src elisp
(setq standard-indent 2)
#+end_src

** projectile
#+begin_src elisp
(setq! projectile-project-search-path '("~/c/"))
#+end_src

*** every project has a =todo.org= and every =todo.org= can just be hardlinks of the same underlying file
This pair of variables is required to let you open the same hardlinked todo.org inode in multiple
project-specific locations in the filesystem, and have each maintain its local context (e.g. when
running projectile functions acting on what filesystem heuristics see as the surrounding VC
project). It's an idiosyncratic pattern, but it works brilliantly for me on work computers.

#+begin_src elisp
(setq! find-file-existing-other-name nil
       find-file-visit-truename nil)

(after! projectile
  (defun amb/goto-project-todos ()
    (interactive)
    ;; TODO dynamically create one if missing? This system can be improved further.
    (find-file (concat (projectile-project-root) "todo.org")))

  (map!
   :leader
   :desc "Open project TODOs.org file" "po" #'amb/goto-project-todos)

  (add-to-list 'projectile-globally-ignored-files "!todo.org")
  (add-to-list 'projectile-globally-ignored-files "!test.http"))
#+end_src

** code compass
#+begin_src elisp :tangle packages.el
(package! code-compass
  :recipe (:host github :repo "ag91/code-compass" :files (:defaults "pages" "scripts")))
#+end_src

#+begin_src elisp
(use-package! code-compass :defer t
              :commands (c/show-hotspots-sync
                         c/show-hotspot-snapshot-sync
                         c/show-code-churn-sync
                         c/show-coupling-graph-sync
                         c/show-code-communication-sync
                         c/show-knowledge-graph-sync
                         c/show-code-age-sync
                         c/show-fragmentation-sync
                         c/show-hotspot-cluster-sync)
              :config
              (setq c/exclude-directories (list "node_modules" "bower_components" "vendor" "tmp" "images"))
              (if IS-MAC (setq c/preferred-browser "open")))
#+end_src
** tree sitter
#+begin_src elisp
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
#+end_src

here's a snippet to install you some language libraries
#+begin_src elisp :tangle no
(mapc #'treesit-install-language-grammar
      (mapcar #'car treesit-language-source-alist))
#+end_src
** non-language-specific IDE shit [0/5]
The gold standard for LSP is VSCode; this goes triply for web development, which uh ✷checks notes✷ is my job.

This is organized by features and is an exercise in aspiration-driven development.  Each
key feature gets a subtree to hold code and/or working notes (an empty subtree for a
desirable feature is better than nothing), and incrementally, over time, I'll muddle my
way through the sea of TODOs and Wouldn't It Be Nices into a future of shininess and feature parity.
Because if I can get /that/, along with all of emacs' land before time shit, I'll be cooking
with fire.

*** TODO LSP actions: code actions, restarting a freaking out server, etc (WHY NOT RUNNING THO)
Auto-imports are handled by code actions; there's a function for that. It uses a vertico
buffer instead of a pop-up, presumably via ~completing-read~, but frankly that's better.
#+begin_src elisp
(after! lsp-mode
  (defun amb/lsp-restart ()
    "The current lsp server? Turn it off and on again."
    (interactive)
    (lsp-disconnect)
    (lsp!))

  (defun amb/lsp-execute-code-action-if-you-are-into-that ()
    "Like lsp-execute-code-action, but in cases where there is only a single available
  action it asks for confirmation rather than unconditionally springing into action."
    ;; TODO implement the logic as described lol
    (call-interactively #'lsp-execute-code-action))

  (defun amb/lsp-dwim ()
    "If there are code actions at point, trigger that. If not, jump to definition."
    (interactive)
    (if (lsp-code-actions-at-point)
        (amb/lsp-execute-code-action-if-you-are-into-that)
      (call-interactively #'+lookup/definition)))

  (map!
   :gnvie "C-M-l" #'lsp-execute-code-action
   (:map lsp-mode-map :n "RET" #'amb/lsp-dwim)

  ;; but, like, it *is* a prefix key???
  ;; manually running this map! form after init works great; I suppose lsp module does some rebinding or some shit
  ;; (map! :leader :desc "restart server" "clR" #'amb/lsp-restart)
  ))

(after! lsp-ui
  (map!
   :leader :desc "show references" "cR" #'lsp-ui-peek-find-references))
#+end_src

I'm not sure about the keybindings. Maybe an extra top-level normal mode command?

**** TODO auto-inserted imports should be organized per project-local eslint rules

*** TODO Actions at point hydra with =<leader>c.=

#+begin_src elisp :tangle no
(defun ide-shit-at-point ()
  (interactive)
  (message "idk, read up on hydras?"))

(map!
 :leader "c." #'ide-shit-at-point)
#+end_src

**** TODO what are the lsp things I want?
| I want to...                       | command                    | key |
|------------------------------------+----------------------------+-----|
| display type                       | ~+lookup/type-definition~    | t   |
| insert inferred type               | [none, it's a code action] | T   |
| rename symbol                      | ~lsp-rename~                 | r   |
| display references                 | ~+lookup/references~         | u   |
| jump to definition                 | ~+lookup/definition~         | d   |
| ⋆waves hands vaguely⋆ code actions | ~lsp-execute-code-action~    | a   |
**** TODO how do I make a hydra again

** the four most frustrating words in the english language: web development in emacs [0/1]
First two sections largely +yoinked from+ courtesy of https://codeberg.org/ckruse/doom.d/src/commit/c6c7163e79a0fecdda6df9e81e60dc246170213a/config.el
*** {t,j}s
#+begin_src elisp :tangle (and "packages.el" "no")
(package! tsi :recipe (:type git :host github :repo "orzechowskid/tsi.el"))
(package! tsx-mode :recipe (:type git :host github :repo "orzechowskid/tsx-mode.el"))
#+end_src

#+begin_src elisp :tangle no
(setq typescript-indent-level 2
      js-indent-level 2)

(use-package! tsx-mode
  :mode (("\\.tsx\\'" . tsx-mode))
  :hook (tsx-mode . lsp!)
  :hook (tsx-mode . rainbow-delimiters-mode)
  :hook (tsx-mode . add-node-modules-path)
  :custom (tsx-mode-tsx-auto-tags  t)
  :defer t
  :init
  (after! flycheck
    (flycheck-add-mode 'javascript-eslint 'tsx-mode))

  (add-hook! 'tsx-mode-hook
    (defun ck/tsx-setup ()
      (flycheck-select-checker 'javascript-eslint)
      (flycheck-add-next-checker 'javascript-eslint 'lsp)
      (pushnew! flycheck-disabled-checkers
                'javascript-jshint
                'tsx-tide
                'jsx-tide)))
#+end_src

*** prettier et al with apheleia (disabled for testing now that elken's module has dropped)
#+begin_src elisp :tangle (or "no" "packages.el")
(package! apheleia)
#+end_src

#+begin_src elisp :tangle no
(use-package! apheleia
  :hook ((tsx-mode . apheleia-mode)
         (typescript-mode . apheleia-mode)
         (typescript-tsx-mode . apheleia-mode)
         (js-mode . apheleia-mode)
         (json-mode . apheleia-mode)
         (css-mode . apheleia-mode)
         (scss-mode . apheleia-mode))
  :defer t
  :config
  (push '(tsx-mode . prettier) apheleia-mode-alist)
  (push '(scss-mode . prettier) apheleia-mode-alist)
  (push '(css-mode . prettier) apheleia-mode-alist))
#+end_src

*** web-mode
#+begin_src elisp
(setq! web-mode-markup-indent-offset 2
       web-mode-css-indent-offset 2
       web-mode-code-indent-offset 2)

(setq! web-mode-engines-alist
       '(;("angular" . "\\.html")
         ("vue" . "\\.vue")
         ("phoenix" . "\\.html\\.eex")
         ("erb" . "\\.html\\.erb")))
#+end_src

*** TODO vue
Meanwhile, this little sucker is just _sitting_ in =custom.el=, hideous. This must be improved.
#+begin_quote
'(auto-insert-alist
'((("\\.vue\\'" . "Vue component")
.
["template.vue" web-mode autoinsert-yas-expand])))
#+end_quote

*** tailwindcss
#+begin_src elisp :tangle packages.el
(package! lsp-tailwindcss :recipe (:host github :repo "merrickluo/lsp-tailwindcss"))
#+end_src

#+begin_src elisp
(use-package! lsp-tailwindcss
  :after lsp)
#+end_src
** there are more languages under the sun than ~:lang~ can speak [0/3]
*** python
**** debugger support, at least in theory
#+begin_src elisp
(after! dap-mode
  (setq dap-python-debugger 'debugpy))
#+end_src
**** TODO use ~python-ts-mode~ by default
**** fold all methods in a class body
- does this need to be python-only? no.
#+begin_src elisp
(after! tree-sitter-langs
  (defun fold-all-methods-in-class ()
    "Fold all methods within the current class in any Tree-sitter-enabled buffer."
    (interactive)
    (let* ((root-node (tsc-root-node tree-sitter-tree))
           (query (tsc-make-query
                   tree-sitter-language
                   "
                 (class_definition
                   body: (block
                     [
                       (function_definition
                         name: (identifier) @method-name
                         body: (block) @method-body)
                       (decorated_definition
                         definition: (function_definition
                           name: (identifier) @method-name
                           body: (block) @method-body))
                     ]
                   ))
                 "))
           (captures (tsc-query-captures query root-node #'tsc--buffer-input)))
      (dotimes (i (length captures))
        (let* ((capture (aref captures i))
               (capture-name (car capture))
               (capture-node (cdr capture)))
          (when (string= capture-name "method-name")
            (save-excursion
              (goto-char (tsc-node-start-position capture-node))
              (+fold/close))))))))
#+end_src

*** TODO is this fennel config needed now that ~(doom! :lang (lua +fennel))~ exists?
#+begin_src elisp :tangle packages.el
(package! fennel-mode)
#+end_src

#+begin_src elisp
(use-package! fennel-mode
  :config (add-to-list 'auto-mode-alist '("\\.fnl\\'" . fennel-mode)))
#+end_src
*** graphql
#+begin_src elisp :tangle packages.el
(package! graphql-mode)
#+end_src

#+begin_src elisp
(use-package! graphql-mode)
#+end_src
*** elixir
#+begin_src elisp
(after! alchemist-mode
  (map! (:when (modulep! :lang elixir)    ; local conditional
          (:map alchemist-mode-map
           :localleader
           "tt" #'exunit-toggle-file-and-test
           "tT" #'exunit-toggle-file-and-test-other-window))))

#+end_src
*** yuck
#+begin_src elisp :tangle packages.el
(package! yuck-mode)
#+end_src
*** scheme, or: you've got gall, you've got guile [0/1]
Apologies to racket, which is a nicer language per se, but guile's already got its grubby
little +mitts+ C ABI in lots of interesting parts of the linux ecosystem and I just don't
have time to shop around. If the list stored at ~geiser-active-implementations~ has length >
1, then every time I restart emacs, I'll be prompted to choose which implementation to
associate with every. single. scheme. buffer. that. I. have. ever. opened. in. my. life.
It gets old fast:
#+begin_src elisp
(setq! geiser-active-implementations '(guile))
#+end_src

Guile's shebang convention is surprisingly well-considered from first principles, in terms
of how it relates to the rest of the language syntax and being a good cross-platform
citizen. It's also weird, complex, and idiosyncratic, and I am apparently incapable of
remembering it.

#+begin_src elisp
(defun insert-guile-shebang ()
  (interactive)
  (save-excursion
    (beginning-of-buffer)
    (insert "#!/usr/local/bin/guile \\
-e main -s
!#

")))
#+end_src

**** TODO move this to =~/.config/guile/config.org= :: pimp my +ride+ .guile
This is my guile repl config. Let's frontload the potentially confusing bit: I would like to rely on the [[https://gitlab.com/NalaGinrut/guile-colorized][guile-colorized]] library, which
is
a) a lovely little quality-of-life improvement, and
b) not packaged with the language

This adds up to a bit of a hassle if one's aim is a config which can be dropped into
different computers and operating systems. My path through the thicket (as of now) is to
add an elisp snippet which shells out to guile to check whether the ~(ice-9 colorized)~
module can be found in the load path; this lets me conditionally tangle the appropriate
version of =~/.guile= accordingly.

Most config is defined outside the conditional top-level src blocks in noweb cookies to
keep things DRY and maintainable.

***** augment load path
#+name: guile-augment-load-path
#+begin_src guile :tangle no
(add-to-load-path (string-append (getenv "HOME") "/lib/scheme"))
#+end_src

***** shared modules
The first line here has ugly indentation so the corresponding noweb cookie (or whatever
the term is) in the source blocks that actually get tangled to =.guile= files can have
pretty indentation.
#+name: guile-shared-modules
#+begin_src guile :tangle no
 (oop goops)
 (srfi srfi-1)
 (srfi srfi-26) ;; cut
 (ice-9 match)
 (ice-9 readline)
#+end_src

***** setup repl
#+name: guile-setup-repl
#+begin_src guile :tangle no
(activate-readline)
#+end_src

***** conditional file templates
#+begin_src guile :noweb yes :tangle (if (string-equal "exists" (shell-command-to-string "test -e `guile -c \"(display (string-append (car %load-path) \\\"/ice-9/colorized.scm\\\"))\"` && echo -n exists")) "~/.guile" "no")
<<guile-augment-load-path>>

(use-modules
 <<guile-shared-modules>>
 (ice-9 colorized))

 <guile-setup-repl>>
(activate-colorized)
#+end_src

But installing a special guile lib and running its (rather manual) installation
process is annoying; until I properly automate it in [[file:~/Makefile][my dotfiles' Makefile]], a
hideously copy-pasted near-duplicate will have to do.
#+begin_src guile :noweb yes :tangle (if (not (string-equal "exists" (shell-command-to-string "test -e `guile -c \"(display (string-append (car %load-path) \\\"/ice-9/colorized.scm\\\"))\"` && echo -n exists"))) "~/.guile" "no")
<<guile-augment-load-path>>

(use-modules
 <<guile-shared-modules>>)

<<guile-setup-repl>>
#+end_src
*** yaml
#+begin_src elisp :tangle packages.el
(package! yaml-pro)
#+end_src

#+begin_src elisp
(use-package! yaml-pro
  :hook (yaml-mode . yaml-pro-mode)
  :hook (yaml-mode . yaml-pro-ts-mode)
  )
#+end_src

This was my OG config; it is not as nice as using a hook, and doesn't use the
tree-sitter-enabled version of ~yaml-pro-mode~. Here for reference, and because the
tree-sitter version requires a semi-manual setup step to install all the language servers.
#+begin_src elisp :tangle no
(use-package! yaml-pro
  :config (add-to-list 'auto-mode-alist '("\\.ya?ml'" . yaml-pro-mode)))
#+end_src
** "I hear lisp is good for AI"
*** copilot
#+begin_src elisp :tangle "packages.el"
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
#+end_src

#+begin_src elisp
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion-by-word)
              ("TAB" . 'copilot-accept-completion-by-word)
              ("C-TAB" . 'copilot-accept-completion)
              ("C-<tab>" . 'copilot-accept-completion)))
#+end_src
*** chatGPT
#+begin_src elisp :tangle packages.el
(package! gptel)
#+end_src

#+begin_src elisp
(use-package! gptel)
#+end_src

* {ma,}git
With apologies to vc-mode, magit is the gold standard. So:
#+begin_src elisp :noweb yes
(after! magit
  <<magit-window-management>>

  <<magit-auto-dash>>

  <<magit-sections>>

  <<magit-custom-actions>>

  <<magithub>>)
#+end_src

Not all the following config has to do with magit, but when it does, it gets tangled into
that ~after!~ form.


** magit status, like the cat in the hat, should clean up after itself
These are fine to set before magit is initialized, so they are directly tangled instead of injected into the ~after!~  block with noweb shenanigans.
#+begin_src elisp :tangle no :noweb-ref magit-window-management
  ;; strictly speaking unnecessary (it's the default)
  ;; (add-hook 'magit-pre-display-buffer-hook #'magit-save-window-configuration)
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq magit-bury-buffer-function #'magit-restore-window-configuration)
#+end_src

** If I can't type a space, why let me?
In scenarios like branch names, whitespace is disallowed. But using the spacebar as a word
separator is deep, deep muscle memory. Why fight it?
#+begin_src elisp :tangle no :noweb-ref magit-auto-dash
  (defun just-use-a-dash-instead-sheesh (_nope &rest _dontcare)
    (interactive)
    (self-insert-command 1 ?-))

  (advice-add 'magit-whitespace-disallowed :around #'just-use-a-dash-instead-sheesh)
#+end_src

** magit-status sections
#+begin_src elisp :tangle no :noweb-ref magit-sections
(setq! magit-section-initial-visibility-alist '((stashes . show) (commits . show)))
#+end_src

** custom actions in magit transients
#+begin_src elisp :tangle no :noweb-ref magit-custom-actions
(defun amb/magit-checkout-default-branch ()
  "Check out the default branch of the current repository."
  (interactive)
  (let ((default-branch (magit-git-string "rev-parse" "--abbrev-ref" "origin/HEAD")))
    (when default-branch
      ;; Strip the 'origin/' part from the branch name
      (let ((branch (replace-regexp-in-string "^origin/" "" default-branch)))
        ;; Checkout the branch using Magit
        (magit--checkout branch)
        (magit-refresh)))))

(transient-append-suffix 'magit-branch "b"
  '("M" "default branch" amb/magit-checkout-default-branch))
#+end_src

** dotfiles
I manage my dotfiles with a bare git repository; this takes a little extra effort to set
up properly. With a hat tip to [[https://github.com/hylophile/.files/blob/d2d41871bd6a74e4b55fadf44d46613d0bcacb53/.config/doom/config.org#dotfiles][hylo]], from whom much of this is adapted.

The song-and-dance is a two-step:
1) open ~magit-status~ for ~~/~ if no orthodox git repo can be found
2) advise ~magit-process-environment~ to set up the correct, unmatched values for ~GIT_WORK_TREE~ and ~GIT_DIR~ if and only if we're getting the status for the ~~/~ repo.

#+begin_src elisp
(defun amb/magit-status-with-dotfiles-fallback ()
  (interactive)
  (if (magit-gitdir)
      (magit-status)
    (magit-status "~/")))

(map! :after magit :leader "g g" #'amb/magit-status-with-dotfiles-fallback)

;; from https://github.com/magit/magit/issues/460

(defun amb/magit-process-environment (env)
  "Add GIT_DIR and GIT_WORK_TREE to ENV when in a special directory."
  (let ((here (file-name-as-directory (expand-file-name default-directory)))
        (home (expand-file-name "~/")))
    (when (string= here home)
      (let ((gitdir (expand-file-name "~/.dots/")))
        (push (format "GIT_WORK_TREE=%s" home) env)
        (push (format "GIT_DIR=%s" gitdir) env))))
  env)

(advice-add 'magit-process-environment
            :filter-return #'amb/magit-process-environment)
#+end_src

This works for almost everything, but there's not yet a good way to stage new files in the
dotfiles repo. So:
#+begin_src elisp
(defun amb/magit-stage-file ()
  (interactive)
  (if (magit-gitdir)
      (call-interactively #'magit-stage-file)
      (shell-command (concat
                      "git --git-dir=$HOME/.dots/ --work-tree=$HOME add "
                      (buffer-file-name))
                     t)))

(map! :after magit :leader "g S" #'amb/magit-stage-file)
#+end_src

I also have to hide my dotfiles away from projectile to avoid caching /way/ too many files
in ~~/~ (until magit can handle separate work trees) properly: Doom recognizes my home
directory as a git dir, but it doesn't find any of its config whatsoever, which can cause
projectile to act silly when it can't find an intermediate project root (either because of
error or because I used the wrong muscle memory).

#+begin_src elisp :tangle no
(after! projectile (setq projectile-project-root-files-bottom-up (remove ".git"
projectile-project-root-files-bottom-up)))

(defun amb/projectile-find-file ()
  (interactive)
  (if (equal (expand-file-name "~/") (projectile-project-root))
    (call-interactively #'find-file)
    (projectile-find-file)))

(map! :leader "SPC" #'amb/projectile-find-file)
#+end_src
** nice git conflic resolution hydra
Gold standard, yes, but not be all and end all. This defines a nice hydra for working with
files containing git conflicts.

#+begin_src elisp
;; all thanks and apologies to https://github.com/alphapapa/unpackaged.el
(use-package! smerge-mode
  :after (hydra magit)
  :config
  (defhydra amb/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  (map! :leader :desc "resolve git conflicts" "gm" #'amb/smerge-hydra/body)
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (amb/smerge-hydra/body)))))
#+end_src

** working with github
#+begin_src elisp :tangle no :noweb-ref magithub
(defun amb/copy-github-permalink ()
  "Generate a GitHub permalink for the current file at the current revision (full SHA).
If a region is active, link to the highlighted line(s)."
  (interactive)
  (let* ((remote-url (magit-get "remote" (magit-get-remote) "url"))
         (repo-url (replace-regexp-in-string
                    (rx string-start
                        "git@"
                        (group (+ (not (any ":")))) ; match domain
                        ":"
                        (group (+ (not (any "."))))
                        (optional ".git")
                        string-end)
                    "https://\\1/\\2" remote-url))
         (full-sha (magit-rev-parse "HEAD"))
         (file-path (magit-file-relative-name buffer-file-name))
         (start-line (line-number-at-pos (region-beginning)))
         (end-line (line-number-at-pos (region-end)))
         (lines (if (use-region-p)
                    (if (= start-line end-line)
                        (format "#L%d" start-line)
                      (format "#L%d-L%d" start-line end-line))
                  ""))
         (permalink (format "%s/blob/%s/%s%s" repo-url full-sha file-path lines)))
    (copy-to-clipboard permalink)
    (message "GitHub permalink: %s" permalink)))
#+end_src

* info-mode, or: RTFM
#+begin_src elisp
(add-to-list '+evil-collection-disabled-list 'info)
(set-evil-initial-state! 'info-mode 'emacs)

(map! :map 'info-mode-map
      "j" #'next-line
      "k" #'previous-line)
#+end_src
* org-mode config [0/1]
** drop it in a box
Notes must be at hand to be helpful, ideally on any of several computers:
#+begin_src elisp
(let ((dir "~/Dropbox/org/"))
  (and (file-exists-p dir)
       (setq org-directory dir)))
#+end_src

** make org-mode act nicer
#+begin_src elisp
(setq! org-log-into-drawer t
       org-hierarchical-todo-statistics nil
       org-refile-use-outline-path 'full-file-path
       org-todo-keywords '((sequence "NEXT(n)" "TODO(t)" "BLOCKED(b)" "SOMEDAY(s)" "PROJ(p)" "QUESTION(q)" "|" "DONE(d)" "CANCELLED(c)")))
#+end_src

** make org-mode look nicer
#+begin_src elisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))

(setq!
 org-hide-emphasis-markers t
 org-agenda-filter-preset '("-quotidian"))

(add-hook! (org-mode) (org-appear-mode 1))
#+end_src

** roam
First, I need a roam directory to serve as the "slipbox":
#+begin_src elisp
(setq org-roam-directory "~/Dropbox/roam/")
#+end_src

I'd like a pretty and interactive graph visualization, too, while I'm at it:
#+begin_src elisp
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

Org-roam-ui tries to keep up with the latest features of org-roam, which conflicts with Doom Emacs's desire for stability. To make sure nothing breaks, use the latest version of org-roam by unpinning it:
#+begin_src elisp :tangle packages.el
(unpin! org-roam)
(package! org-roam-ui)
#+end_src

** the yet-neglected agenda view
These values can be dynamically constructed by concatenating the values of
~org-roam-directory~ and ~org-roam-dailies-directory~; I did try to use those to make this
more future-proof, but that just passed along the unresolved symbol names (I assume
because ~setq~ is a macro) and everything went to heck.
#+begin_src elisp
(setq! org-agenda-files '("~/Dropbox/org/"
                          "~/Dropbox/roam/daily/"))

(defun org-my-auto-exclude-fn (tag)
  (if (cond
       ;; TODO show only the next 2
       ((string= tag "quotidian")
        t)
       ;; only see work things between 8am and 7pm
       ((string= tag "work")
        (let ((hr (nth 2 (decode-time))))
          (or (< hr 8) (> hr 19)))))
      (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'org-my-auto-exclude-fn)

#+end_src

** keybinding fixes
I wonder if this is a kkp/CSIu thing? i.e. org expects to receive ~(kbd "TAB")~ but instead gets ~(kbd "<tab>")~.

#+begin_src elisp
(after! org
  (map! :after org
        :map 'org-mode-map
        "<tab>" 'org-cycle)

  (defun my-org-mode-backtick-replacement ()
    "Replace a single backtick with = and triple backticks with a code block template."
    (interactive)
    (let ((context (buffer-substring-no-properties (max (point-min) (- (point) 2)) (point))))
      (if (string= context "==")
          (progn
            (delete-char -2)
            (insert "#+begin_src \n#+end_src\n")
            (forward-line -1)
            (move-beginning-of-line nil)
            (backward-char))
        (insert "="))))

  (defun my-org-mode-key-remap ()
    "Remap ` to custom function in org-mode."
    (local-set-key (kbd "`") 'my-org-mode-backtick-replacement))

  (add-hook 'org-mode-hook 'my-org-mode-key-remap))

#+end_src

** outlines ✨ everywhere ✨with outshine
#+begin_src elisp :tangle packages.el
(package! outshine
  :recipe (:host github :repo "alphapapa/outshine"))
#+end_src

#+begin_src elisp
(use-package! outshine
  :after org
  :config
  (add-hook 'prog-mode-hook 'outshine-mode))
#+end_src
** graphviz 📉_(ツ)_📈
#+begin_src elisp :tangle packages.el
(package! graphviz-dot-mode)
#+end_src

#+begin_src elisp
(use-package! graphviz-dot-mode
  :after org)
#+end_src
** export backends
#+begin_src elisp :tangle packages.el
(package! ox-gfm)
#+end_src

#+begin_src elisp
;; TODO: figure out doom's org exporter API
;; (after! org
;;   '(require 'ox-gfm nil t))
(use-package! ox-gfm
  :after org)

#+end_src

** no noweb? no: noweb.
This snippet is taken directly from the org-mode info manual.
#+begin_src elisp
(setq org-babel-default-header-args
      (cons '(:noweb . "yes")
            (assq-delete-all :noweb org-babel-default-header-args)))

#+end_src

* emacs is so great, why have just one?
#+begin_src elisp :tangle profiles.el
(
 <<emacs-profile-list>>
 )
#+end_src

** we don't /need/ to make doom the default, but if I make a CLI profile switcher it simplifies things
#+begin_src elisp :tangle no :noweb-ref emacs-profile-list
(default)
#+end_src

** nano emacs here I come
#+begin_src elisp :tangle no :noweb-ref emacs-profile-list
(nano (user-emacs-directory . "~/.config/emacsen/nano"))
#+end_src

* appendices
** TODO uncategorized keybindings :: clean up
#+begin_src elisp
(map!
 :leader
 :desc "prior buffer" "=" #'evil-switch-to-windows-last-buffer
 "Nr" #'narrow-to-region
 "Nf" #'narrow-to-defun
 "Np" #'narrow-to-page
 "Ns" #'org-toggle-narrow-to-subtree
 "Nw" #'widen
 :desc "jump to first non-blank" "of" #'evil-first-non-blank
 :desc "new frame" "oF" #'make-frame
 "W" #'subword-mode)

(map!
 "C-;" #'evil-avy-goto-char-timer
 :ni "C-)" #'sp-forward-slurp-sexp
 :ni "C-(" #'sp-backward-slurp-sexp
 (:when (not (display-graphic-p)) :map (evil-insert-state-map evil-motion-state-map) "C-z" #'suspend-frame))
#+end_src

** Who configures the configuration?
I do.

[a definitely very cool picture goes here eventually, probably]

*** whoami
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Alex Birdsall"
      user-mail-address "ambirdsall@gmail.com")
#+end_src

*** shortcuts to open doom config file(s)
#+begin_src elisp
(defvar amb/computer-specific-config (expand-file-name "local.el" doom-private-dir)
  "A file for computer-specific config, hidden from git; for
example, configuration for a work computer and its (possibly
private) product projects.")

(map! :leader
      :desc "open doom config" "F" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
      :desc "open doom config" "fP" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
      :desc "open computer-specific doom config" "fL" (cmd! (find-file amb/computer-specific-config)))
#+end_src

*** what kind of spaceship doesn't come with a spedometer?
#+begin_src elisp :tangle no
(package! benchmark-init)
#+end_src

*** a literate config, tangled asynchronously
This is shamelessly lifted from [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur's config]]; since you seem to be the sort of
eccentric who reads emacs configs, odds are good that either you're already familiar with
it or you should be.

#+begin_src emacs-lisp
(defvar +literate-tangle--proc nil)
(defvar +literate-tangle--proc-start-time nil)

(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (unless (getenv "__NOTANGLE")
    (let ((default-directory doom-private-dir))
      (when +literate-tangle--proc
        (message "Killing outdated tangle process...")
        (set-process-sentinel +literate-tangle--proc #'ignore)
        (kill-process +literate-tangle--proc)
        (sit-for 0.3)) ; ensure the message is seen for a bit
      (setq +literate-tangle--proc-start-time (float-time)
            +literate-tangle--proc
            (start-process "tangle-config"
                           (get-buffer-create " *tangle config*")
                           "emacs" "--batch" "--eval"
                           (format "(progn \
(require 'ox) \
(require 'ob-tangle) \
(setq org-confirm-babel-evaluate nil \
      org-inhibit-startup t \
      org-mode-hook nil \
      write-file-functions nil \
      before-save-hook nil \
      after-save-hook nil \
      vc-handled-backends nil \
      org-startup-folded nil \
      org-startup-indented nil) \
(org-babel-tangle-file \"%s\" \"%s\"))"
                                   +literate-config-file
                                   (expand-file-name doom-module-config-file))))
      (set-process-sentinel +literate-tangle--proc #'+literate-tangle--sentinel)
      (run-at-time nil nil (lambda () (message "Tangling config.org"))) ; ensure shown after a save message
      "Tangling config.org...")))

(defun +literate-tangle--sentinel (process signal)
  (cond
   ((and (eq 'exit (process-status process))
         (= 0 (process-exit-status process)))
    (message "Tangled config.org sucessfully (took %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))
   ((memq (process-status process) (list 'exit 'signal))
    (pop-to-buffer (get-buffer " *tangle config*"))
    (message "Failed to tangle config.org (after %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))))

(defun +literate-tangle-check-finished ()
  (when (and (process-live-p +literate-tangle--proc)
             (yes-or-no-p "Config is currently retangling, would you please wait a few seconds?"))
    (switch-to-buffer " *tangle config*")
    (signal 'quit nil)))
(add-hook! 'kill-emacs-hook #'+literate-tangle-check-finished)

#+end_src

** top-of-file preambles
*** packages.el
#+begin_src elisp :tangle no :noweb-ref packages-preamble
;; -*- no-byte-compile: t; -*-

#+end_src

*** config.el
#+begin_src elisp :tangle no :noweb-ref config-preamble
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; commentary: what the fuck

#+end_src
** The secrets I keep with myself, or: praise the Lord and pass the =.gitignore=
This snippet loads a computer-specific config file if it's present. It goes
last, giving me a convenient place for ad hoc overrides of any setting in here.
#+begin_src elisp
(let ((amb/computer-specific-config (concat doom-private-dir "local.el")))
  (and (file-exists-p amb/computer-specific-config) (load amb/computer-specific-config)))
#+end_src
** text manipulation utility macros
Working with text combines a huge variety of content-specific considerations with a very
narrow, consistent API; there are a lot of repetitive definitions. Let's improve that:
#+begin_src elisp :tangle no :noweb-ref text-manipulation-metafns
(defmacro cmds--on-string-or-region (fn)
  "Given a string-manipulation function FN, defines an interactive command which will apply that
function to either a string argument or to selected text, depending on context."
  `(lambda (string &optional from to)
     (interactive
      (if (use-region-p)
          (list nil (region-beginning) (region-end))
        (let ((bds (bounds-of-thing-at-point 'paragraph)))
          (list nil (car bds) (cdr bds)))))

     (let* ((work-on-string? (if string t nil))
            (input-str (if work-on-string?
                           string
                         (buffer-substring-no-properties from to)))
            (output-str (funcall ,fn input-str)))

       (if work-on-string?
           output-str
         (save-excursion
           (delete-region from to)
           (goto-char from)
           (insert output-str))))))

;; TODO use defalias instead of fset so docstrings can be set
(defmacro def-text-transform (name fn)
  "Create a new interactive command bound to NAME using some
string manipulation function FN. It will work given a string
argument programmatically or by operating on selected text when
used interactively."
  `(fset ,name (cmds--on-string-or-region ,fn)))
#+end_src

* Footnotes

[fn:1] This is the white-on-white crime our politicians /should/ be talking about, if you ask me.

# Local Variables:
# org-indent-mode: nil
# End:
