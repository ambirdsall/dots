#+TITLE: Alex Birdsall's doom emacs config
#+startup: overview
#+PROPERTY: header-args :noweb yes

This is my doom config. It's a literate config, so the code snippets are living documentation; they
get exported to specific init files.

* reference
** keybindings in doom
:PROPERTIES:
:VISIBILITY: folded
:END:
This will define =SPC f b b= to invoke foo-bar-baz and =SPC f b q= to invoke foo-bar-qux.
#+begin_src elisp :tangle no
(map! :leader

	(:prefix-map ("f" . "foo")
		(:prefix ("b" . "bar")
		:desc "Baz" "b" #'foo-bar-baz
		:desc "Qux" "q" #'foo-bar-qux)))
#+end_src

** emacs package wish/learning list
:PROPERTIES:
:VISIBILITY: folded
:END:
*** actually installed
**** [[https://github.com/abo-abo/auto-yasnippet][aya]] :: auto-yasnippet (installed by doom)
**** [[https://github.com/oantolin/embark][embark]]
*** wishing and thinking
**** [[https://github.com/thisisran/nova][nova]] :: stylish-compatible svg child frames

* begin config files at the beginning
#+begin_src elisp
<<config-preamble>>
#+end_src

In order to conditionally define config, we have some toggles which can be overridden via a non-git-tracked local file:
#+begin_src elisp
<<default-toggles>>
<<load-local-toggle-overrides>>
#+end_src

#+begin_src elisp :tangle packages.el
<<packages-preamble>>
#+end_src

#+begin_src elisp :tangle init.el
<<init-preamble>>

<<init-preconfig>>

<<doom-block>>
#+end_src

* doom modules
#+begin_src elisp :tangle no :noweb-ref doom-block
(doom!
 <<doom-modules>>)
#+end_src

** installation
To bootstrap a literate =init.el= on a new computer, it's necessary to first run something like
#+begin_src shell :tangle no
echo "(doom! :config literate)" > ~/.config/doom/init.el
#+end_src
so that the /actual/ module selections will be tangled upon running ~doom {install,sync}~;
however, these dotfiles do that for you (me) via ~make install~, so this note is primarily
for the benefit of a hypothetical reader hoping to yoink the emacs config, the whole emacs
config, and nothing but the emacs config. Look, you never know.

** =:input=
#+begin_src elisp :tangle no :noweb-ref -doom-modules
:input
;;chinese
;;japanese
;;layout            ; auie,ctsrnm is the superior home row
#+end_src

** =:completion=
#+begin_src elisp :tangle no :noweb-ref doom-modules
:completion
(company          ; the ultimate code completion backend
 +childframe)
(vertico +icons)
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules
;; (corfu +icons +orderless)  ; complete with cap(f), cape and a flying feather!
;; helm              ; the *other* search engine for love and life
;;ido               ; the other *other* search engine...
;; ivy               ; a search engine for love and life
#+end_src

** =:ui=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:ui
<<doom-modules-ui>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-ui
doom              ; what makes DOOM look the way it does
doom-dashboard    ; a nifty splash screen for Emacs
(emoji +unicode)  ; üôÇ
hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
(:if (display-graphic-p)
    (ligatures
     +extra))    ; ligatures and symbols to make your code pretty again
modeline          ; snazzy, Atom-inspired modeline, plus API
ophints           ; highlight the region an operation acts on
(popup +defaults)   ; tame sudden yet inevitable temporary windows
(vc-gutter +pretty) ; vcs diff in the fringe
vi-tilde-fringe   ; fringe tildes to mark beyond EOB
workspaces        ; tab emulation, persistence & separate workspaces
zen               ; distraction-free coding or writing
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-ui
;;deft              ; notational velocity for Emacs
;; doom-quit         ; DOOM quit-message prompts when you quit Emacs
;; indent-guides     ; highlighted indent columns
;;minimap           ; show a map of the code on the side
;;nav-flash         ; blink cursor line after big motions
;;neotree           ; a project drawer, like NERDTree for vim
;;tabs              ; a tab bar for Emacs
;;treemacs          ; a project drawer, like neotree but cooler
;;unicode           ; extended unicode support for various languages
;;window-select     ; visually switch windows
#+end_src

** =:editor=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:editor
<<doom-modules-editor>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-editor
(evil +everywhere +hybrid) ; come to the dark side, we have cookies
file-templates     ; auto-snippets for empty files
fold               ; (nigh) universal code folding
(format +onsave) ;; when commented out, $DAYJOB has too many badly-formatted files
;;format ; automated prettiness
snippets           ; my elves. They type so I don't have to
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-editor
;;god              ; run Emacs commands without modifier keys
;;lispy            ; vim for lisp, for people who don't like vim
;;multiple-cursors ; editing in many places at once
;;objed            ; text object editing for the innocent
;;parinfer         ; turn lisp into python, sort of
;;rotate-text      ; cycle region at point between text candidates
;;word-wrap        ; soft wrapping with language-aware indent
#+end_src

** =:emacs=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:emacs
<<doom-modules-emacs>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-emacs
undo                ; persistent, smarter undo for your inevitable mistakes
vc                  ; version-control and Emacs, sitting in a tree
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-emacs
;;electric            ; smarter, keyword-based electric-indent
;;ibuffer           ; interactive buffer management
#+end_src

** =:term=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:term
<<doom-modules-term>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-term
vterm             ; the best terminal emulation in Emacs
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-term
;;eshell            ; the elisp shell that works everywhere
;;shell             ; simple shell REPL for Emacs
;;term              ; basic terminal emulator for Emacs
#+end_src

** =:checkers=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:checkers
<<doom-modules-checkers>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-checkers
syntax            ; tasing you for every semicolon you forget
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-checkers
;;spell             ; tasing you for misspelling mispelling
;;grammar           ; tasing grammar mistake every you make
#+end_src

** =:tools=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:tools
<<doom-modules-tools>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-tools
(debugger +lsp)     ; FIXME stepping through code, to help you add bugs
direnv
docker
editorconfig      ; let someone else argue about tabs vs spaces
(eval +overlay)     ; run code, run (also, repls)
(lookup +docsets)   ; navigate your code and its documentation
(lsp +peek)
(magit
+forge)          ; a git porcelain for Emacs
make              ; run make tasks from Emacs
pdf               ; pdf enhancements
tmux              ; an API for interacting with tmux
tree-sitter       ; syntax and parsing, sitting in a tree...
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-tools
;;ansible
;;biblio            ; Writes a PhD for you (citation needed)
;;collab            ; buffers with friends
;;ein               ; tame Jupyter notebooks with emacs
;;gist              ; interacting with github gists
;;pass              ; password manager for nerds
;;prodigy           ; FIXME managing external services & code builders
;;rgb               ; creating color strings
;;terraform         ; infrastructure as code
;;upload            ; map local to remote projects via ssh/ftp
#+end_src

** =:os=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:os
<<doom-modules-os>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-os
(:if IS-MAC macos)  ; improve compatibility with macOS
tty               ; improve the terminal Emacs experience
#+end_src

** =:lang=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:lang
<<doom-modules-lang>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-lang
(clojure +lsp +treesitter)           ; java with a lisp
data              ; config/data formats
(elixir +lsp)            ; erlang done right
emacs-lisp        ; drown in parentheses
(json +lsp)              ; At least it ain't XML
(javascript
  +lsp
  +tree-sitter)        ; all(hope(abandon(ye(who(enter(here))))))
(lua
  +fennel
  +lsp)                 ; one-based indices? one-based indices
markdown            ; writing docs for people to ignore
(org                ; organize your plain life in plain text
  +pretty
  +dragndrop
  +present
  +gnuplot
  +roam2)
(python             ; beautiful is better than ugly
  +lsp
  +pyright
  +tree-sitter)
rest              ; Emacs as a REST client
(ruby
  +rails
  +rbenv
  +lsp
  +tree-sitter)        ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(scheme +guile)   ; a fully conniving family of lisps

(sh
  +lsp
  +tree-sitter)        ; she sells {ba,z,fi}sh shells on the C xor
(web
  +lsp
  +tree-sitter)        ; the tubes
(yaml
  + lsp
  +tree-sitter)        ; JSON, but readable
#+end_src

#+begin_src elisp :tangle no :noweb-ref -doom-modules-lang
;;agda              ; types of types of types of types...
;;beancount         ; mind the GAAP
;; cc                ; C/C++/Obj-C madness
;;(clojure +lsp)           ; java with a lisp
;;common-lisp       ; if you've seen one lisp, you've seen them all
;;coq               ; proofs-as-programs
;;crystal           ; ruby at the speed of c
;;csharp            ; unity, .NET, and mono shenanigans
;;(dart +flutter)   ; paint ui and not much else
;;dhall
;;elm               ; care for a cup of TEA?
;;erlang            ; an elegant language for a more civilized age
;;ess               ; emacs speaks statistics
;;factor
;;faust             ; dsp, but you get to keep your soul
;;fortran           ; in FORTRAN, GOD is REAL (unless declared INTEGER)
;;fsharp            ; ML stands for Microsoft's Language
;;fstar             ; (dependent) types and (monadic) effects and Z3
;;gdscript          ; the language you waited for
;;(go +lsp)         ; the hipster dialect
;;(graphql +lsp)    ; Give queries a REST
;;(haskell +lsp)    ; a language that's lazier than I am
;;hy                ; readability of scheme w/ speed of python
;;idris             ; a language you can depend on
;; (:if IS-LINUX
;;     (java
;;      +meghanada
;;      +tree-sitter)) ; the poster child for carpal tunnel syndrome
;; (:if IS-MAC
;;     (java
;;      +tree-sitter)) ; the poster child for carpal tunnel syndrome
;;julia             ; a better, faster MATLAB
;; (kotlin +lsp)            ; a better, slicker Java(Script)
;;latex             ; writing papers in Emacs has never been so fun
;;lean
;;ledger            ; an accounting system in Emacs
;;nim               ; python + lisp at the speed of c
;;nix               ; I hereby declare "nix geht mehr!"
;;ocaml             ; an objective camel
;;php               ; perl's insecure younger brother
;;plantuml          ; diagrams for confusing people more
;;purescript        ; javascript, but functional
;;qt                ; the 'cutest' gui framework ever
;;racket            ; a DSL for DSLs
;;raku              ; the artist formerly known as perl6
;;rst               ; ReST in peace
;;(rust +lsp)       ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala             ; java, but good
;;sml
;;solidity          ; do you need a blockchain? No.
;;swift             ; who asked for emoji variables?
;;terra             ; Earth and Moon in alignment for performance.
;;zig               ; C, but simpler
#+end_src

** =:email=
#+begin_src elisp :tangle no :noweb-ref -doom-modules

:email
<<doom-modules-email>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-email
;;(mu4e +org +gmail)
;;notmuch
;;(wanderlust +gmail)
#+end_src

** =:app=
#+begin_src elisp :tangle no :noweb-ref -doom-modules

:app
<<doom-modules-app>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-app
;;calendar
;;;everywhere        ; *leave* Emacs!? You must be joking
;;irc               ; how neckbeards socialize
;;(rss +org)        ; emacs as an RSS reader
#+end_src

** =:config=
#+begin_src elisp :tangle no :noweb-ref doom-modules

:config
<<doom-modules-config>>
#+end_src

#+begin_src elisp :tangle no :noweb-ref doom-modules-config
literate
(default +bindings +smartparens)
#+end_src

* work nicely with the surrounding computer
** clipboard
By default, editing stuff in emacs shouldn't pollute the system clipboard:
#+begin_src elisp
(setq! select-enable-clipboard nil)

#+end_src

Pasting from the system clipboard should be easy:
#+begin_src elisp
(map! "C-M-y" #'clipboard-yank)

#+end_src

And capturing text to it should be, too. To write this, I just copy-pasted the actual source of ~evil-yank~
and added ~select-enable-clipboard~ and ~select-enable-primary~ to the ~let~ form around the
logic:
#+begin_src elisp
(evil-define-operator evil-yank-to-clipboard (beg end type register yank-handler)
  "Save the characters in motion into the kill-ring."
  :move-point nil
  :repeat nil
  (interactive "<R><x><y>")
  (let ((evil-was-yanked-without-register
         (and evil-was-yanked-without-register (not register)))
        (select-enable-clipboard t)
        (select-enable-primary t))
    (cond
     ((and (fboundp 'cua--global-mark-active)
           (fboundp 'cua-copy-region-to-global-mark)
           (cua--global-mark-active))
      (cua-copy-region-to-global-mark beg end))
     ((eq type 'block)
      (evil-yank-rectangle beg end register yank-handler))
     ((memq type '(line screen-line))
      (evil-yank-lines beg end register yank-handler))
     (t
      (evil-yank-characters beg end register yank-handler)
      (goto-char beg)))))

(map! :map evil-normal-state-map "Y" #'evil-yank-to-clipboard)
(map! :map evil-motion-state-map "Y" #'evil-yank-to-clipboard)

#+end_src

Those are great for interactive use; now let's make programmatically adding text to the
system clipboard nice and easy, too:
#+begin_src elisp
(defun copy-to-clipboard (string)
  "Copies `STRING' to the system clipboard and the kill ring. When called interactively,
the active region will be used."
  (interactive
   (when (region-active-p)
     (list (buffer-substring-no-properties (region-beginning) (region-end)))))
  (let ((select-enable-clipboard t)
        (select-enable-primary t))
    (kill-new string)))

#+end_src

This one is just for funsies:
#+begin_src elisp
(defun copy-unicode-char-to-clipboard ()
  "Interactively select a unicode character and copy it to the system clipboard."
  (interactive)
  (with-temp-buffer
    (call-interactively #'insert-char)
    (let ((char (buffer-string)))
      (copy-to-clipboard char)
      (message "%s" (concat "Copied " char " to system clipboard")))))

#+end_src

** macOS shenanigans
this config [[https://en.wikipedia.org/wiki/Unitarian_Universalist_Association#Principles_and_purposes][covenants to affirm and promote the inherent worth and dignity]] of every computer it's installed on, even macs
I was raised by and around a bunch of earnest, wordy people; deal with it.

#+begin_src elisp
(setq! mac-command-modifier 'meta
       mac-option-modifier 'meta
       ns-function-modifier 'super)
#+end_src

*** trouble? shoot it.
Sometimes on macOS, emacs will throw a constant stream of errors that end with "Too many open files" all over itself. The solution, per [[https://www.blogbyben.com/2022/05/gotcha-emacs-on-mac-os-too-many-files.html][this blog post]]?
#+begin_src elisp :tangle no
(file-notify-rm-all-watches)
#+end_src

Also, I have had certain macOS computers on which emacs consistently has a misdefined
~woman-manpath~, which is weird! Particularly since ~(describe-variable 'woman-manpath)~
will report a functioning, correct-looking original value. If this hits you, you'll need
to reset the value in =~/.config/doom/local-config.el= so it's manually set correctly. Or rerun
~doom env~ on the command line in a context where ~MANPATH~ is correct. Here is a minimal
(i.e. with all nonstandard and/or versioned paths from language-specific package manager
installation locations removed) reference version:
#+begin_src elisp :tangle no
(setq! woman-manpath
       '("/opt/homebrew/share/man/"
         "/usr/share/man/"
         "/usr/local/share/man/"
         "/usr/share/man"
         "/usr/local/share/man"
         "/usr/X11/man"
         "/Library/Apple/usr/share/man"))
#+end_src

** I didn't shell out, I bought in
Leaving the untangled manual config in place for a bit so things work with my computers
which aren't running a super up-to-date version of doom.

Relatedly, leaving this in =packages.el= so I can just dump the activation code in =local-config.el= if needed.
#+begin_src elisp :tangle packages.el
(package! kkp)
#+end_src

The naive config +(for why it's disabled see immediately below)+ it is now re-enabled but tbh I'm not sure if it will actually fix my minor grievances:
#+begin_src elisp
(use-package! kkp
  :if (not (display-graphic-p))
  :config
  (global-kkp-mode +1)
  (define-key! local-function-key-map
    [M-return] (kbd "M-RET")
    [M-tab] (kbd "M-TAB")
    [M-backspace] (kbd "M-DEL")
    (kbd "M-<backspace>") (kbd "M-DEL")
    [M-delete] (kbd "M-DEL")))
#+end_src

The following snipped was added as a test at Henrik's request; it does what I want, and
presumably somehow is better optimized for doom's loading than the above.
#+begin_src elisp tangle no
(add-hook! 'tty-setup-hook :depth -90
  (defun +tty-init-kkp-h ()
    (global-kkp-mode +1)
    (kkp-enable-in-terminal)))
#+end_src

*** better terminal keycode handling with =kkp=

*** use OSC52 for clipboard integration to avoid issues inside multiplexers
#+begin_src elisp :tangle packages.el
(package! clipetty)
#+end_src

#+begin_src elisp
(use-package! clipetty
  :if (not (display-graphic-p))
  :hook (after-init . global-clipetty-mode))
#+end_src
** don't leave trash in other people's servers
By default, TRAMP will happily litter remote servers/devcontainers/etc with lockfiles any
time there are unsaved changes. 'Tis nobler to brave the slings and arrows of outrageous
networks.
#+begin_src elisp
(setq remote-file-name-inhibit-locks t)
#+end_src

TRAMP also starts with a pretty bare-bones, generic executable path, which does not play
well with even slightly sandboxed tooling--which means the following config is needed to
connect with remote lsp servers if they were installed with one of quite a few
language-specific package managers:
#+begin_src elisp
(after! tramp
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src
* text editing per se
** text manipulation utilities [0/1]
See the =text manipulation utility macros= appendix for deets.
#+begin_src elisp
<<text-manipulation-metafns>>
#+end_src
*** ~(not-every programming_language({conventionallyUses: "THE_SAME_CASING"}))~
Let's make some helper commands for manipulating the casing of programming symbols. Since
they are defined with ~def-text-transform~, they're usable as elisp string utilities and as
a command on region both.
#+begin_src elisp
(def-text-transform 'kebab-case #'s-dashed-words
                     "Make a string arg kebab case. If called interactively with a region active, replaces the selected text with its kebab case equivalent.

For example, any of `(kebab-case \"foo bar\")', `(kebab-case \"foo_bar\")', or `(kebab-case \"fooBar\")' will return `\"foo-bar\"'.")
(def-text-transform 'pascal-case #'s-upper-camel-case)
(def-text-transform 'camel-case #'s-lower-camel-case)
(def-text-transform 'snake-case #'s-snake-case)
(def-text-transform 'screaming-snake-case #'(lambda (str) (s-upcase (s-snake-case str))))
(def-text-transform 'lower-words-case #'(lambda (str) (s-join " " (-map #'s-downcase (s-split-words str)))))
#+end_src

*** manipulate numbers at point
sooo these are built-in to either emacs or evil, i think?

NIH, not my problem, fuck it

#+begin_src elisp
(defun decrement-number-at-point ()
  "Decrement the number at point by 1."
  (interactive)
  (save-excursion
    (skip-chars-backward "0-9")
    (when (looking-at "[0-9]+")
      (let ((num (string-to-number (match-string 0))))
        (replace-match (number-to-string (1- num)))))))

(defun increment-number-at-point ()
  "Increment the number at point by 1."
  (interactive)
  (save-excursion
    (skip-chars-backward "0-9")
    (when (looking-at "[0-9]+")
      (let ((num (string-to-number (match-string 0))))
        (replace-match (number-to-string (1+ num)))))))

(map! :leader
      :desc "decrement at point" "nj" #'decrement-number-at-point
      :desc "increment at point" "nk" #'increment-number-at-point)
#+end_src
** completion
*** built-in completions
Might as well use the more powerful built-in expansion system:
#+begin_src elisp
(map! [remap dabbrev-expand] #'hippie-expand)
#+end_src

*** company-mode
Turns out, I get extremely annoyed when emacs lags because ispell is second-guessing my
writing the english language!
#+begin_src elisp
(setq company-global-modes '(not text-mode org-mode))
#+end_src

** an opinionated mix of the vim and emacs keybinding schemes [0/3]
This largely relies on the following setting. In practice, this has only worked for me when it's set before loading doom, so it must be tangled into the start of =init.el=, rather than the default =config.el=:

#+begin_src elisp :tangle no :noweb-ref init-preconfig
(setq evil-disable-insert-state-bindings t)
#+end_src

With this set, the rest is mainly just tweaking which modes and keys are evilified;
=evil-collection= et al do too much boilerplate legwork to not install, but occasionally
clobber insert mode's emacs bindings in ways that compromise basic ergonomics. Got to make
sure this yak's hair looks cute after all.

*** TODO make the long-threatened PR adding a ~+hybrid~ flag to the evil module
This was my first draft, which I think... mostly worked?
#+begin_src diff :tangle no
diff --git a/modules/editor/evil/config.el b/modules/editor/evil/config.el
index db274fab2..344ccf8c0 100644
--- a/modules/editor/evil/config.el
+++ b/modules/editor/evil/config.el
@@ -420,6 +420,9 @@ directives. By default, this only recognizes C directives.")
     "#" #'evil-visualstar/begin-search-backward))


+(when (modulep! +hybrid)
+  (setq! evil-disable-insert-state-bindings t))
+
 ;;
 ;;; Text object plugins

diff --git a/modules/lang/markdown/config.el b/modules/lang/markdown/config.el
index 6602d1339..4bec4c332 100644
--- a/modules/lang/markdown/config.el
+++ b/modules/lang/markdown/config.el
@@ -137,7 +137,8 @@ capture, the end position, and the output buffer.")
         :n "TAB" #'markdown-cycle
         :n [backtab] #'markdown-shifttab
         :i "M-*" #'markdown-insert-list-item
-        :i "M-b" #'markdown-insert-bold
+        (:when (not (modulep! :editor evil +hybrid)) :i "M-b" #'markdown-insert-bold)
+        (:when (modulep! :editor evil +hybrid) :i "M-B" #'markdown-insert-bold)
         :i "M-i" #'markdown-insert-italic
         :i "M-`" #'+markdown/insert-del
         :i "M--" #'markdown-insert-hr
#+end_src

**** TODO are there (still?) load-order problems when running ~(setq! evil-disable-insert-state-bindings t)~ at a normal time (i.e. not hella early)?
I recall (now too vaguely smh) that it only has worked for me when I put that (in a vanilla ~setq~ form) in ~init.el~, but not in ~config.el~. Why?

*** [DEPRECATED] wait, is this split two tmux panes or two emacs windows?
+WHO CARES+

So this used to be my JAM (I mean, just note the account hosting that fork's repo), but
increased usage of vanilla emacs bindings, both in emacs and zsh, eventually lead me to
prefer having =C-k= as ~kill-line~ to having a universal, super-accessible binding for
navigating up a split in all my various terminal contexts. Pour one out, we had a good run.

#+begin_src elisp :tangle no
(package! evil-tmux-navigator
  :recipe (:host github :repo "ambirdsall/evil-tmux-navigator"))
(unpin! evil-tmux-navigator)
#+end_src

#+begin_src elisp :tangle no
(use-package! evil-tmux-navigator
  :config (evil-tmux-navigator-bind-keys))
#+end_src

Now, all elegies aside, I do semi-frequently use my tmux split navigation command (now
=prefix+{h,j,k,l}= rather than =ctrl+{h,j,k,l}=) when I intend to navigate a TUI emacs split.
It would be good to revisit the package in a way that makes it workable with my current
keybinding scheme as well sometime.
*** replace with register
#+begin_src elisp :tangle packages.el
(package! evil-replace-with-register)
#+end_src

#+begin_src elisp
(use-package! evil-replace-with-register
  :init
  (setq evil-replace-with-register-key (kbd "gr"))
  :config (evil-replace-with-register-install))
#+end_src
*** evil-exchange
#+begin_src elisp :tangle packages.el
(package! evil-exchange)
#+end_src

#+begin_src elisp
(use-package! evil-exchange
  :config (evil-exchange-install))
#+end_src
*** matchit
#+begin_src elisp :tangle packages.el
(package! evil-matchit)
#+end_src

#+begin_src elisp
(use-package! evil-matchit
  :config (global-evil-matchit-mode 1))
#+end_src
*** changing up some default settings
**** evil defaults
#+begin_src elisp
(setq! evil-ex-search-persistent-highlight nil
       +evil-want-o/O-to-continue-comments nil)
#+end_src

**** doom defaults
WHEREAS =M-x= works perfectly fine in all modes; and WHEREAS zellij's =kkp= implementation (as of v0.42.2) doesn't handle a few bindings correctly, notably including =M-:=; let's go ahead and switch those up.
#+begin_src elisp
(map! :leader ":" #'eval-expression)
#+end_src

And you can have my ~evil-substitute~ when you pry it from my cold, dead fingers.
#+begin_src elisp :tangle packages.el
(package! evil-snipe :disable t)
#+end_src

*** imenu
I much prefer evil's indentation command set, making the default ~M-i~ binding,
~tab-to-tab-stop~, a rather poor use of prime real estate. I would be much better served
using it as a mnemonic binding for ~imenu~:
#+begin_src elisp
(map! :after consult "M-i" #'consult-imenu)
#+end_src

*** TODO jump into/around a visual selection
=SPC v= is (or was, at time of writing) not a default binding in [[file:~/.emacs.d/modules/config/default/+evil-bindings.el][doom's default evil bindings]]; that seems like a potential oversight.

- If region is not active, works like vim's =gv=
- else, DWIM selection changes
  + cycle through structural selectors?
    - if tree mode is available?
  + that "expand visual selection" package
  + ?

*** evil text objects
#+begin_src elisp
;; this macro was copied from someone who copied it from here: https://stackoverflow.com/a/22418983/4921402
(after! evil
  (defmacro define-and-bind-quoted-text-object (name key start-regex end-regex)
    (let ((inner-name (make-symbol (concat "evil-inner-" name)))
          (outer-name (make-symbol (concat "evil-a-" name))))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map ,key #',inner-name)
         (define-key evil-outer-text-objects-map ,key #',outer-name))))
  (define-and-bind-quoted-text-object "dollar" "$" "\\$" "\\$")
  (define-and-bind-quoted-text-object "pipe" "|" "|" "|")
  (define-and-bind-quoted-text-object "slash" "/" "/" "/")
  (define-and-bind-quoted-text-object "space" " " " " " ")
  (define-and-bind-quoted-text-object "tilda" "~" "~" "~")
  (define-and-bind-quoted-text-object "asterisk" "*" "*" "*"))
#+end_src
**** line text object
#+begin_src elisp :tangle packages.el
(package! evil-textobj-line
  :recipe (:host github :repo "emacsorphanage/evil-textobj-line"))
#+end_src

#+begin_src elisp
(use-package! evil-textobj-line
  :after evil)
#+end_src

** snippets
*** doom has some tooling to make snippets nicer
**** TODO tangle the line enabling the =snippets= module to =init.el= here
**** enable the =doom-snippets= short helpers
#+begin_src elisp
(setq! doom-snippets-enable-short-helpers 't)
#+end_src

Quoth the readme,
#+begin_src md :tangle no
If this variable is non-nil, this package will define the following shortcut
function aliases for your convenience:

+ `!%!` = `(doom-snippets-format "%n%s%n")`
+ `!%` = `(doom-snippets-format "%n%s")`
+ `%$` = `(doom-snippets-format "%>")`
+ `(%expand ...)` = `(doom-snippets-expand ...)`
+ `(%format ...)` = `(doom-snippets-format ...)`
+ `(%without-trigger ...)` = `(doom-snippets-without-trigger ...)`
#+end_src
*** my own personal snippets
**** org-mode
***** =<p!= :: a =package!= form inside the boilerplate literate config source block
#+begin_src snippet :tangle snippets/org-mode/<p!
# -*- mode: snippet -*-
# name: doom literate package block
# key: <p!
# --
,#+begin_src elisp :tangle packages.el
(package! $1)
,#+end_src
$0
#+end_src
***** =<todos= :: a custom dynamic block to collect todo statistics from the whole document
:PROPERTIES:
:CUSTOM_ID: todos-snippet
:END:
#+begin_src snippet :tangle snippets/org-mode/<todos
# -*- mode: snippet -*-
# name: dynamic block for whole-doc statistics cookie
# key: <todos
# --
,#+BEGIN: all-todo-stats
,#+END
#+end_src
* emacs UI shit (buffers, windows, frames, workspaces, ...) [0/5]
** =command-log-mode=, or: wait shit hold on what just happened
#+begin_src elisp :tangle packages.el
(package! command-log-mode)
#+end_src

#+begin_src elisp
(use-package! command-log-mode)
#+end_src

** window navigation
*** hydra at =SPC W= / =SPC w.=
#+begin_src elisp
(defhydra amb/window-nav-hydra (:hint nil :exit nil)
  "
Navigate Windows (exit with RET, ESC, q, or C-g)
  ^Navigate^
  _h_ ‚Üê  _j_ ‚Üì  _k_ ‚Üë  _l_ ‚Üí

  ^Rearrange^
  _H_ ‚Üê  _J_ ‚Üì  _K_ ‚Üë  _L_ ‚Üí
  _x_ Close _s_/_v_ Split

  ^Repurpose^
  _._ Nearby file  _p_/_SPC_ Project file  _r_ Recent file
"
  ;; Navigation
  ("h" evil-window-left)
  ("j" evil-window-down)
  ("k" evil-window-up)
  ("l" evil-window-right)

  ;; Move windows
  ("H" +evil/window-move-left)
  ("J" +evil/window-move-down)
  ("K" +evil/window-move-up)
  ("L" +evil/window-move-right)

  ;; Act on windows
  ("x" +workspace/close-window-or-workspace)
  ("." find-file)
  ("p" projectile-find-file)
  ("SPC" projectile-find-file)
  ("r" consult-recent-file)
  ("s" evil-window-split)
  ("v" evil-window-vsplit)

  ;; Exit hydra
  ("RET" nil :exit t)
  ("ESC" nil :exit t)
  ("q" nil :exit t)
  ("C-g" nil :exit t))

(map! :leader
      :desc "get movin'" "w." #'amb/window-nav-hydra/body
      :desc "Manage windows" "W" #'amb/window-nav-hydra/body)
#+end_src

*** ace-window
#+begin_src elisp :tangle packages.el
(package! ace-window)
#+end_src

#+begin_src elisp

(use-package! ace-window
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
        aw-scope 'frame
        aw-dispatch-always 't
        aw-dispatch-alist '((?x aw-delete-window "Delete Window")
                            (?m aw-swap-window "Swap Windows")
                            (?M aw-move-window "Move Window")
                            (?c aw-copy-window "Copy Window")
                            (?b aw-switch-buffer-in-window "Select Buffer")
                            (?B aw-switch-buffer-other-window "Switch Buffer Other Window")
                            (?n aw-flip-window)
                            (?c aw-split-window-fair "Split Fair Window")
                            (?v aw-split-window-vert "Split Vert Window")
                            (?z aw-split-window-horz "Split Horz Window")
                            (?o delete-other-windows "Delete Other Windows")
                            (?? aw-show-dispatch-help)))
  (map! :leader "ww" #'ace-window)
  (custom-set-faces!
  '(aw-leading-char-face
    :foreground "white" :background "dark green"
    :weight bold :height 2.5 :box (:line-width 10 :color "dark green"))))
#+end_src
** files, both local and remote
*** Wha's like us? Damn few and they're all =dired=
There's a doom module for dired with some preconfigured niceties:
#+begin_src elisp :tangle no :noweb-ref doom-modules-emacs
(dired +dirvish +icons)               ; making dired pretty [functional]
#+end_src

While I do mostly like =dirvish= (my only beef is when I visit a directory in one window and
that causes a different =dirvish=-enhanced =dired= buffer in a different window to /leave the
fucking directory I left it in/), I do prefer more marginalia in my directory buffers than the doom
default:
#+begin_src elisp
(after! dirvish
  (setq! dirvish-attributes '(collapse git-msg file-size)))
#+end_src

note to self: doom sets this on line 93 of =~/.emacs.d/modules/emacs/dired/config.el=

*** oops, I need to ~sudo~ edit this file
#+begin_src elisp
(defun sudo ()
  "Use TRAMP to `sudo' the current buffer."
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+end_src
*** copy a filepath from the project root
#+begin_src elisp
(after! projectile
  (defun yank-buffer-filename-relative-to-project ()
    "Copy the current buffer's path, relative to the project root, to the kill ring."
    (interactive)
    (if-let (filename (or buffer-file-name (bound-and-true-p list-buffers-directory)))
        (message (kill-new (f-relative filename (projectile-acquire-root))))
      (error "Couldn't find filename in current buffer")))

  (map! :leader "fY" #'yank-buffer-filename-relative-to-project))

#+end_src

*** jump to arbitrary files in specific projects/directories from anywhere
#+begin_src elisp
(after! projectile
  (defmacro file-jumper-for-project (project-root)
    "Defines an anonymous interactive function for picking an arbitrary file from the given PROJECT-ROOT.

Conveniently, by explicitly providing the project root, you can use the conveniently
flattened file hierarchy generated by `projectile-project-files' regardless of whether
projectile would recognize your root directory as a project."
    `(cmd! (find-file (string-join
                       (list
                        ,project-root
                        (projectile-completing-read "Find file: " (projectile-project-files ,project-root)))
                       "/"))))

  (defun file-jumper-for-dots ()
    (interactive)
    (find-file
     (completing-read "Open dotfile: "
                      (split-string (shell-command-to-string "dots ls-files ~") "\n"))))

  (map! :leader
        :desc "Browse dotfiles" "f." #'file-jumper-for-dots
        :desc "Take me $HOME, country roads" "f~" (cmd! (+vertico/find-file-in "~/"))
        :prefix ("fj" . "Jump into specific projects")
        :desc "Browse ~/.config/" :ne "c" (file-jumper-for-project "~/.config/")
        :desc "Browse ~/bin/" :ne "b" (file-jumper-for-project "~/bin/")
        :desc "Browse dotfiles" :ne "d" #'file-jumper-for-dots))
#+end_src
** scratch buffer
If they're in org, that's good for notes and I can still write/exec code
#+begin_src elisp
(setq! doom-scratch-initial-major-mode 'org-mode)
#+end_src

** don't automatically open a new workspace for each new emacsclient frame
I like freely opening client instances in the terminal and desktop environment alike; when
doing so, a 1:1 mapping with workspaces quickly creates a terrible clutter.
#+begin_src elisp
(after! persp-mode (setq! persp-emacsclient-init-frame-behaviour-override -1))
#+end_src

** Don't confirm before quitting
I said what I said.
#+begin_src elisp
(setq confirm-kill-emacs nil)
#+end_src
** appearance
*** splash screen [0/1]
For additional reference, see [[https://discourse.doomemacs.org/t/how-to-change-your-splash-screen/57][this doom discourse post]].

**** make it look nice
I don't rely on the short menu anymore; I know how to get around in doom/emacs just fine now. Let's get rid of that. And while we're at it, let's replace the splash image with something nice:
#+begin_src elisp
(setq fancy-splash-image (concat doom-private-dir "emacs.png"))
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-footer)
#+end_src

**** TODO make it super useful
Hat tip to [[https://tecosaur.github.io/emacs-config/config.html#dashboard-quick-actions][tecosaur's config]], whence much of this came. First off, let's make it easy to
open the dashboard:
#+begin_src elisp :tangle no
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

Teco adds some additional code to clean
up the appearance of the dashboard; this could use some similar TLC as a follow-up.

*For now, this is disabled (via ~:tangle no~); despite the bindings being tagged with ~:ne~,
they are, in practice, only being added to the emacs-state map.*

#+begin_src elisp :tangle no
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Previous buffer" :ne "p" #'previous-buffer
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

*** typography [0/1]
**** fonts
Emacs handles missing fonts /spectacularly/ poorly: rather than gracefully working through a
list of user-defined and default fallbacks, it crashes without even the courtesy of a
useful error message. The point being: make sure these fonts are installed upfront.
#+begin_src elisp
(setq doom-font-increment 1
      doom-font (font-spec :family "Victor Mono" :size (if IS-MAC 13 16) :weight 'semi-bold)
      ;; doom-font (font-spec :family "Iosevka Fixed Slab" :size 16 :weight 'medium)
      doom-big-font (font-spec :family "Victor Mono" :size (if IS-MAC 20 26))
      doom-variable-pitch-font (font-spec :family "Overpass" :size (if IS-MAC 15 20))
      doom-serif-font (font-spec :family "Iosevka Slab" :size (if IS-MAC 13 16))
      ;; doom-unicode-font (font-spec :family "Iosevka" :size (if IS-MAC 13 16)))
      doom-unicode-font (font-spec :family "Victor Mono" :size (if IS-MAC 13 16)))
#+end_src
We‚Äôd like to use mixed pitch in certain modes. If we simply add a hook, when directly
opening a file with (a new) Emacs, ~mixed-pitch-mode~ runs before UI initialisation, which is
problematic. To resolve this, we create a hook that runs after UI initialisation and both
- conditionally enables ~mixed-pitch-mode~
- sets up the mixed pitch hooks
#+begin_src elisp
(defvar mixed-pitch-modes '(org-mode markdown-mode gfm-mode Info-mode text-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

Additionally, there are emojis:
#+begin_src elisp :tangle packages.el
(package! emojify)
#+end_src

**** TODO try out [[https://www.reddit.com/r/emacs/comments/shzif1/n%CE%BBno_font_stack/][NANO emacs font stack]]
I mean, it's nice.

**** whitespace
#+begin_src elisp
(whitespace-mode 1)
#+end_src
*** theme this bad boy [0/1]
I should really wrap all theme config in a single ~(unless noninteractive <theme config>)~ form and =noweb= in the different logical sections
**** that said...
***** Define a theme switcher utility [0/1]
Sometimes (usually) I want dark mode; sometimes (presenting, in direct sunlight, or just
mixing it up) I want light mode. What I do /not/ want is to have to pick a specific theme
out of a haystack by name each time I want to toggle between light and dark; give me
instead the blithe simplicity of a lightswitch flipped in passing.

#+begin_src elisp
(unless noninteractive
  (setq
   amb/doom-dark-theme 'doom-one
   amb/doom-light-theme (if (display-graphic-p) 'modus-operandi 'doom-one-light))

  (defun amb/toggle-themes ()
    "Cycle through a set of predefined themes according to whatever unholy logic is currently residing in its inner `cond' form."
    (interactive)
    (cond ((eq doom-theme amb/doom-dark-theme) (load-theme amb/doom-light-theme))
          (t (load-theme amb/doom-dark-theme))))

  (map! :leader
        "tt" #'amb/toggle-themes)

  (load-theme amb/doom-dark-theme t))
#+end_src


****** TODO use a ring instead of imperatively toggling btw hardcoded vars
- [ ] look up rings in elisp manual lol
- [ ] create a container var that is, you guessed it,,,
- [ ] iterate through that in ~amb/toggle-themes~

***** [legacy] modus themes config
The modus themes (included with emacs since version twenty-eight point something) are a
thoughtfully-designed, goal-oriented set of color themes, designed for accessibility and
readability (high-contrast, anti-deuteranopic variants) and sporting delightfully-paired
names:
- /modus operandi/ :: Mode, or manner, of that which is to be worked. The light color theme, for one's toil under the sun.
- /modus vivendi/ :: Mode, or manner, of living. The dark color theme, for one's toil under monitor glare.

I don't use either one anymore‚ÄîI appreciate their philosophical bent, but the extra
marginal config required to get them as cute as a nice choice out of ~doom-themes~ is hard
to justify. The real turning point, though, was discovering that when using tty emacs,
~modus-operandi~'s usage of colors from the terminal color theme meant that switching both
emacs and the surrounding terminal emulator to a light theme (as when working outside on a
sunny day) made the primary text face a unreadable.[fn:1]

Speaking of toggling switches, the modus themes expose quite a few semantically-named
variables for users to tweak; let's do so.

By default, as of writing, ~modus-vivendi~ uses a background color of ~#000000~ and text color
of ~#ffffff~. This pairing provides a /glaring/ degree of contrast; while that's in line with
the stated goals of the themes, let's tone it down just a touch. A touch of blue gives the
background a subtle "night sky" vibe; a touch of red makes the foreground text warmer.
We'll also want a corresponding adjustment to the background color of highlighted (i.e.
current) lines.

#+begin_src elisp :tangle no
(unless noninteractive
  (require-theme 'modus-themes)

  (setq modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-syntax (list 'alt-syntax 'yellow-comments)
        modus-themes-vivendi-color-overrides
        '((bg-main . "#0d0b11")
          (fg-main . "#ffeeee")
          (bg-hl-line . "#29272f"))
        modus-themes-operandi-color-overrides
        '((bg-hl-line . "#eeeeee"))))
#+end_src

*** line numbers
This determines the style of line numbers in effect. The options:
- ~t~ :: lines are numbered by which line they are in the file
- ~relative~ :: lines numbered by distance from current line in the file
- ~visual~ :: lines numbered by distance from current line on screen
- ~nil~ :: lines aren't numbered

I like absolute line numbers occasionally, and always when pairing/screen sharing. I like relative line numbers whenever I'm doing vim-style navigation. Turns out there's a way to get some of each:
#+begin_src elisp
(setq display-line-numbers-type 't)

(after! evil
  (add-hook! '(evil-operator-state-entry-hook evil-visual-state-entry-hook)
    (setq display-line-numbers 'relative))

  (add-hook! '(evil-operator-state-exit-hook evil-visual-state-exit-hook)
    (setq display-line-numbers 't)))
#+end_src
*** long lines: don't do 'em
#+begin_src elisp
(setq! fill-column 90)
(global-visual-line-mode -1)
#+end_src
*** Window title
I‚Äôd like to have just the buffer name, then if applicable the project folder

#+begin_src elisp
(setq frame-title-format
      '(""
        (:eval
         (if-let ((workspace-name (safe-persp-name (get-current-persp))))
           (format "%s ‚ãÆ " workspace-name)))
        (:eval
         (let ((project-name (projectile-project-name))
               (workspace-name (safe-persp-name (get-current-persp))))
           (unless (or (string= "-" project-name) (string= workspace-name project-name))
             (format (if (buffer-modified-p)  " ‚óâ %s / " " %s / ") project-name))))
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "‚ò∞ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))))
#+end_src


For example when I open my config file it the window will be titled config.org ‚óè doom then as soon as I make a change it will become config.org ‚óâ doom.
*** tab bar :: display workspaces [0/2]
Taken from [[https://discourse.doomemacs.org/t/permanently-display-workspaces-in-the-tab-bar/4088][hylo's discourse post]], thanks hylo.

Notably, clicking on the tabs accomplishes nothing helpful with this setup.
#+begin_src elisp :tangle no :noweb-ref default-toggles
(defvar amb/enable-workspace-tabs nil
  "Do I really want to show tabs of the workspace names?")

#+end_src

#+begin_src elisp
(custom-set-faces!
  '(+workspace-tab-face :inherit default :family "Overpass" :height 135)
  '(+workspace-tab-selected-face :inherit (highlight +workspace-tab-face)))

(after! persp-mode
  (defun workspaces-formatted ()
    ;; fancy version as in screenshot
    (+doom-dashboard--center (frame-width)
                             (let ((names (or persp-names-cache nil))
                                   (current-name (safe-persp-name (get-current-persp))))
                               (mapconcat
                                #'identity
                                (cl-loop for name in names
                                         for i to (length names)
                                         collect
                                         (concat (propertize (format " %d" i) 'face
                                                             `(:inherit ,(if (equal current-name name)
                                                                             '+workspace-tab-selected-face
                                                                           '+workspace-tab-face)
                                                               :weight bold))
                                                 (propertize (format " %s " name) 'face
                                                             (if (equal current-name name)
                                                                 '+workspace-tab-selected-face
                                                               '+workspace-tab-face))))
                                " "))))
  (defun amb/invisible-current-workspace ()
    "The tab bar doesn't update when only faces change (i.e. the
current workspace), so we invisibly print the current workspace
name as well to trigger updates"
    (propertize (safe-persp-name (get-current-persp)) 'invisible t))

  (customize-set-variable 'tab-bar-format '(workspaces-formatted tab-bar-format-align-right amb/invisible-current-workspace))

  ;; don't show current workspaces when we switch, since we always see them
  (advice-add #'+workspace/display :override #'ignore)
  ;; same for renaming and deleting (and saving, but oh well)
  (advice-add #'+workspace-message :override #'ignore)

  ;; need to run this later for it to not break frame size for some reason
  (run-at-time
   nil
   nil
   (cmd!
    (when amb/enable-workspace-tabs
      (tab-bar-history-mode)
      (tab-bar-mode +1)))))

#+end_src

This one is no better, but it /is/ simpler. Perhaps it's a better starting point for making a clickable version?
#+begin_src elisp :tangle no
(after! persp-mode
  ;; alternative, non-fancy version which only centers the output of +workspace--tabline
  (defun workspaces-formatted ()
    (+doom-dashboard--center (frame-width) (+workspace--tabline)))

  (defun hy/invisible-current-workspace ()
    "The tab bar doesn't update when only faces change (i.e. the
current workspace), so we invisibly print the current workspace
name as well to trigger updates"
    (propertize (safe-persp-name (get-current-persp)) 'invisible t))

  (customize-set-variable 'tab-bar-format '(workspaces-formatted tab-bar-format-align-right hy/invisible-current-workspace))

  ;; don't show current workspaces when we switch, since we always see them
  (advice-add #'+workspace/display :override #'ignore)
  ;; same for renaming and deleting (and saving, but oh well)
  (advice-add #'+workspace-message :override #'ignore))

;; need to run this later for it to not break frame size for some reason
(run-at-time nil nil (cmd! (tab-bar-mode +1)))
#+end_src

Having made this nice tab bar, we need a way to toggle it: some modes (notably PDFView)
have rendering logic that doesn't play nicely with (or is not properly aware of) the tab
bar.

#+begin_src elisp
(map! :leader
      :desc "toggle tab bar" "tT" #'tab-bar-mode)
#+end_src

**** TODO Mouse click bindings for the tab bar
A normal click on a tab navigates to it (optionally, if not the current one). Right clicking brings up a menu of nice things to be able to do.

**** TODO PDFView mode does not take tab bar height into account when rendering a page
The end result is having to scroll a small amount whenever I (\*Bob Seger voice*) turn the
page, which is frankly a bit annoying. A shitty workaround is to manually toggle, I guess.
*** window sizing
This is a nice little thing:
#+begin_src elisp :tangle packages.el
(package! golden-ratio)
#+end_src

It's automatic resizing behavior is overkill, but it's nice to be able to easily opt-in:
#+begin_src elisp
(use-package! golden-ratio
  :config
  (dolist
      (fn '(evil-window-left evil-window-down evil-window-up evil-window-right))
    (add-to-list 'golden-ratio-extra-commands fn))
  (map! :leader
        "wG" #'golden-ratio
        "wgg" #'golden-ratio-mode))
#+end_src

So. Sometimes the current window just needs to be a little more. Let's make that situation nice and easy to handle:
#+begin_src elisp
(defvar amb--more-current-window-original-sizes (make-hash-table :test 'eq)
  "A hash table storing the original sizes of windows so they can be restored by `amb/more-current-window'.")

(defun amb--more-current-window-save-original-size (win)
  "Ensure the window configuration relative to a window object `WIN' is stored.
Window sizes are stored in `amb--more-current-window-original-sizes'."
  (unless (gethash win amb--more-current-window-original-sizes)
    (puthash win (current-window-configuration) amb--more-current-window-original-sizes)))

(defun amb/more-current-window ()
  "Make the current window larger based on predefined breakpoints.
If the window occupies the entire frame, restore its original size."
  (interactive)
  (let* ((win (selected-window))
         (frame-width (frame-width))
         (window-width (window-total-width win)))
    (cond
     ;; If the window is maximized, restore its original size.
     ((and (window-full-width-p win) (window-full-height-p win))
      (message "there and, uh,")
      (when-let ((orig-size (gethash win amb--more-current-window-original-sizes)))
        (message "and back again")
        (set-window-configuration orig-size)
        (remhash win amb--more-current-window-original-sizes)))
     ;; If the width is less than 50% of the frame, increase it to 50%.
     ;; Yes, I compare against 48%, not 50%; I don't want to be stuck at 50% when I want *more*
     ((< (/ (float window-width) frame-width) 0.48)
      (message "fiddy")
      (amb--more-current-window-save-original-size win)
      (let ((target-width (floor (* 0.50 frame-width))))
        (adjust-window-trailing-edge win (- target-width window-width) t)))
     ;; If the width is less than 61% of the frame, use golden-ratio.
     ((< (/ (float window-width) frame-width) 0.61)
      (message "goldy")
      (amb--more-current-window-save-original-size win)
      (call-interactively #'golden-ratio))
     ;; If the width is less than 70%, enlarge the window.
     ((< (/ (float window-width) frame-width) 0.70)
      (message "biggie")
      (amb--more-current-window-save-original-size win)
      (doom/window-enlargen))
     ;; Otherwise, maximize the window.
     (t
      (message "all that and then some")
      (amb--more-current-window-save-original-size win)
      (doom/window-maximize-buffer)))))

;; Bind the command to the leader key.
(map! :leader
      :desc "more of current window"
      "wM" #'amb/more-current-window)
#+end_src

* programming
** Indent however you wish, as long as you do it right
#+begin_src elisp
(setq standard-indent 2)
#+end_src

** managing projects with projectile
Set things up so projects are automatically discovered in my default code directory:
#+begin_src elisp
(setq! projectile-project-search-path '("~/c/"))
#+end_src

And undo the doom default that maps projects to workspaces:
#+begin_src elisp
(after! projectile
  (setq! projectile-switch-project-action #'projectile-find-file))
#+end_src

*** every project has a =todo.org= and every =todo.org= can just be hardlinks of the same underlying file
This pair of variables is required to let you open the same hardlinked todo.org inode in multiple
project-specific locations in the filesystem, and have each maintain its local context (e.g. when
running projectile functions acting on what filesystem heuristics see as the surrounding VC
project). It's an idiosyncratic pattern, but it exactly fits what I want on work computers.

#+begin_src elisp
(setq! find-file-existing-other-name nil
       find-file-visit-truename nil)

(after! projectile
  (defun amb/goto-project-todos ()
    (interactive)
    ;; TODO dynamically create one if missing? This system can be improved further.
    (find-file (concat (projectile-project-root) "todo.org")))

  (map!
   :leader
   :desc "Open project TODOs.org file" "po" #'amb/goto-project-todos)

  (add-to-list 'projectile-globally-ignored-files "!todo.org")
  (add-to-list 'projectile-globally-ignored-files "!test.http"))
#+end_src

** code compass
#+begin_src elisp :tangle packages.el
(package! code-compass
  :recipe (:host github :repo "ag91/code-compass" :files (:defaults "pages" "scripts")))
#+end_src

#+begin_src elisp
(use-package! code-compass :defer t
              :commands (c/show-hotspots-sync
                         c/show-hotspot-snapshot-sync
                         c/show-code-churn-sync
                         c/show-coupling-graph-sync
                         c/show-code-communication-sync
                         c/show-knowledge-graph-sync
                         c/show-code-age-sync
                         c/show-fragmentation-sync
                         c/show-hotspot-cluster-sync)
              :config
              (setq c/exclude-directories (list "node_modules" "bower_components" "vendor" "tmp" "images"))
              (if IS-MAC (setq c/preferred-browser "open")))
#+end_src
** tree sitter
#+begin_src elisp
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (janet-simple "https://github.com/sogaiu/tree-sitter-janet-simple")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))
#+end_src

here's a snippet to install you some language libraries
#+begin_src elisp :tangle no
(mapc #'treesit-install-language-grammar
      (mapcar #'car treesit-language-source-alist))
#+end_src
** non-language-specific IDE shit [0/5]
The gold standard for LSP is VSCode; this goes triply for web development, which uh ‚ú∑checks notes‚ú∑ is my job.

This is organized by features and is an exercise in aspiration-driven development.  Each
key feature gets a subtree to hold code and/or working notes (an empty subtree for a
desirable feature is better than nothing), and incrementally, over time, I'll muddle my
way through the sea of TODOs and Wouldn't It Be Nices into a future of shininess and feature parity.
Because if I can get /that/, along with all of emacs' land before time shit, I'll be cooking
with fire.

*** TODO LSP actions: code actions, restarting a freaking out server, etc (WHY NOT RUNNING THO)
Auto-imports are handled by code actions; there's a function for that. It uses a vertico
buffer instead of a pop-up, presumably via ~completing-read~, but frankly that's better.
#+begin_src elisp
(after! lsp-mode
  (defun amb/lsp-restart ()
    "The current lsp server? Turn it off and on again."
    (interactive)
    (lsp-disconnect)
    (lsp!))

  (defun amb/lsp-execute-code-action-if-you-are-into-that ()
    "Like lsp-execute-code-action, but in cases where there is only a single available
  action it asks for confirmation rather than unconditionally springing into action."
    ;; TODO implement the logic as described lol
    (call-interactively #'lsp-execute-code-action))

  (defun amb/lsp-dwim ()
    "If there are code actions at point, trigger that. If not, jump to definition."
    (interactive)
    (if (lsp-code-actions-at-point)
        (amb/lsp-execute-code-action-if-you-are-into-that)
      (call-interactively #'+lookup/definition)))

  (map!
   :gnvie "C-M-l" #'lsp-execute-code-action
   (:map lsp-mode-map :n "RET" #'amb/lsp-dwim)

  ;; but, like, it *is* a prefix key???
  ;; manually running this map! form after init works great; I suppose lsp module does some rebinding or some shit
  ;; (map! :leader :desc "restart server" "clR" #'amb/lsp-restart)
  ))

(after! lsp-ui
  (map!
   :leader :desc "show references" "cR" #'lsp-ui-peek-find-references))
#+end_src

I'm not sure about the keybindings. Maybe an extra top-level normal mode command?

**** TODO auto-inserted imports should be organized per project-local eslint rules

*** TODO Actions at point hydra with =<leader>c.=

#+begin_src elisp :tangle no
(defun ide-shit-at-point ()
  (interactive)
  (message "idk, read up on hydras?"))

(map!
 :leader "c." #'ide-shit-at-point)
#+end_src

**** TODO what are the lsp things I want?
| I want to...                       | command                    | key |
|------------------------------------+----------------------------+-----|
| display type                       | ~+lookup/type-definition~    | t   |
| insert inferred type               | [none, it's a code action] | T   |
| rename symbol                      | ~lsp-rename~                 | r   |
| display references                 | ~+lookup/references~         | u   |
| jump to definition                 | ~+lookup/definition~         | d   |
| ‚ãÜwaves hands vaguely‚ãÜ code actions | ~lsp-execute-code-action~    | a   |
**** TODO how do I make a hydra again

** the four most frustrating words in the english language: web development in emacs [0/1]
First two sections largely +yoinked from+ courtesy of https://codeberg.org/ckruse/doom.d/src/commit/c6c7163e79a0fecdda6df9e81e60dc246170213a/config.el
*** {t,j}s
#+begin_src elisp :tangle (and "packages.el" "no")
(package! tsi :recipe (:type git :host github :repo "orzechowskid/tsi.el"))
(package! tsx-mode :recipe (:type git :host github :repo "orzechowskid/tsx-mode.el"))
#+end_src

#+begin_src elisp :tangle no
(setq typescript-indent-level 2
      js-indent-level 2)

(use-package! tsx-mode
  :mode (("\\.tsx\\'" . tsx-mode))
  :hook (tsx-mode . lsp!)
  :hook (tsx-mode . rainbow-delimiters-mode)
  :hook (tsx-mode . add-node-modules-path)
  :custom (tsx-mode-tsx-auto-tags  t)
  :defer t
  :init
  (after! flycheck
    (flycheck-add-mode 'javascript-eslint 'tsx-mode))

  (add-hook! 'tsx-mode-hook
    (defun ck/tsx-setup ()
      (flycheck-select-checker 'javascript-eslint)
      (flycheck-add-next-checker 'javascript-eslint 'lsp)
      (pushnew! flycheck-disabled-checkers
                'javascript-jshint
                'tsx-tide
                'jsx-tide)))
#+end_src

*** prettier et al with apheleia (disabled for testing now that elken's module has dropped)
#+begin_src elisp :tangle (or "no" "packages.el")
(package! apheleia)
#+end_src

#+begin_src elisp :tangle no
(use-package! apheleia
  :hook ((tsx-mode . apheleia-mode)
         (typescript-mode . apheleia-mode)
         (typescript-tsx-mode . apheleia-mode)
         (js-mode . apheleia-mode)
         (json-mode . apheleia-mode)
         (css-mode . apheleia-mode)
         (scss-mode . apheleia-mode))
  :defer t
  :config
  (push '(tsx-mode . prettier) apheleia-mode-alist)
  (push '(scss-mode . prettier) apheleia-mode-alist)
  (push '(css-mode . prettier) apheleia-mode-alist))
#+end_src

*** web-mode
#+begin_src elisp
(setq! web-mode-markup-indent-offset 2
       web-mode-css-indent-offset 2
       web-mode-code-indent-offset 2)

(setq! web-mode-engines-alist
       '(;("angular" . "\\.html")
         ("vue" . "\\.vue")
         ("phoenix" . "\\.html\\.eex")
         ("erb" . "\\.html\\.erb")))
#+end_src

*** TODO vue
Meanwhile, this little sucker is just _sitting_ in =custom.el=, hideous. This must be improved.
#+begin_quote
'(auto-insert-alist
'((("\\.vue\\'" . "Vue component")
.
["template.vue" web-mode autoinsert-yas-expand])))
#+end_quote

*** tailwindcss
#+begin_src elisp :tangle packages.el
(package! lsp-tailwindcss :recipe (:host github :repo "merrickluo/lsp-tailwindcss"))
#+end_src

#+begin_src elisp
(use-package! lsp-tailwindcss
  :after lsp)
#+end_src
** there are more languages under the sun than ~:lang~ can speak [0/3]
*** ruby
#+begin_src elisp
(after! rbenv
  (global-rbenv-mode +1))

(after! lsp-mode
  (add-to-list 'lsp-language-id-configuration '(ruby-mode . "ruby"))
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection (lambda () '("bundle" "exec" "standardrb" "--lsp")))
                    :major-modes '(ruby-mode)
                    :server-id 'standardrb-lsp)))

(after! apheleia
  (add-to-list 'apheleia-mode-alist '(ruby-mode . ruby-standard)))
#+end_src
*** python
**** debugger support, at least in theory
#+begin_src elisp
(after! dap-mode
  (setq dap-python-debugger 'debugpy))
#+end_src
**** TODO use ~python-ts-mode~ by default
**** fold all methods in a class body
- does this need to be python-only? no.
#+begin_src elisp
(after! (tree-sitter-langs consult)
  (defun fold-all-methods-in-class ()
    "Fold all methods within the current class in any Tree-sitter-enabled buffer."
    (interactive)
    (let* ((root-node (tsc-root-node tree-sitter-tree))
           (query (tsc-make-query
                   tree-sitter-language
                   "
                 (class_definition
                   body: (block
                     [
                       (function_definition
                         name: (identifier) @method-name
                         body: (block) @method-body)
                       (decorated_definition
                         definition: (function_definition
                           name: (identifier) @method-name
                           body: (block) @method-body))
                     ]
                   ))
                 "))
           (captures (tsc-query-captures query root-node #'tsc--buffer-input)))
      (dotimes (i (length captures))
        (let* ((capture (aref captures i))
               (capture-name (car capture))
               (capture-node (cdr capture)))
          (when (string= capture-name "method-name")
            (save-excursion
              (goto-char (tsc-node-start-position capture-node))
              (+fold/close)))))))

  (defun amb/tree-sitter-list-functions ()
    "Extract function and method definitions with class and function nesting using Tree-sitter."
    (let* ((root-node (tsc-root-node tree-sitter-tree))
           ;; Tree-sitter query to capture function definitions
           (query (tsc-make-query
                   tree-sitter-language
                   "
                 (function_definition
                   name: (identifier) @func-name)
                 "))
           (captures (tsc-query-captures query root-node #'tsc--buffer-input))
           (current-nest '()) ;; Stack to track class/function nesting
           (functions '()))   ;; Store the functions to return for Imenu
      (dotimes (i (length captures))
        (let* ((capture (aref captures i))
               (func-node (cdr capture))
               (func-name (tsc-node-text func-node))
               ;; Determine function's starting position
               (pos (tsc-node-start-position func-node)))
          ;; Update current nesting context by checking parent nodes
          (setq current-nest (amb/get-nesting-context func-node))
          ;; Create the Imenu entry
          (push (cons (string-join (append current-nest (list func-name)) " / ") pos) functions)))
      ;; Return functions, reversing the order
      (nreverse functions)))

  (defun amb/get-nesting-context (node)
    "Get the nesting context (class or function names) for a function."
    (let (context)
      (while (setq node (tsc-get-parent node))
        (cond
         ;; Capture class names for Python-like languages
         ((string= (tsc-node-type node) "class_definition")
          (push (tsc-node-text (tsc-get-child-by-field node :name)) context))
         ;; Capture outer function names
         ((string= (tsc-node-type node) "function_definition")
          (push (tsc-node-text (tsc-get-child-by-field node :name)) context))))
      context))

  (defun amb/setup-tree-sitter-imenu ()
    "Set up Imenu using Tree-sitter to extract function and method definitions."
    (if tree-sitter-mode
        (setq-local lsp-enable-imenu nil
                    lsp-ui-enable-imenu nil
                    imenu-create-index-function #'amb/tree-sitter-list-functions)
      (kill-local-variable 'imenu-create-index-function)))

  ;; Automatically enable for all tree-sitter-enabled modes
  (add-hook 'tree-sitter-mode-hook #'amb/setup-tree-sitter-imenu))

  (defun amb/show-nesting-context-at-point ()
    "Show the nesting context for the Tree-sitter node at point."
    (interactive)
    (let* ((node-at-point (tsc-get-descendant-for-position-range
                           (tsc-root-node tree-sitter-tree)
                           (point) (point)))
           (nesting-context (amb/get-nesting-context node-at-point)))
      (message "Nesting context: %s" (string-join nesting-context " / "))))
#+end_src
**** structural navigation
Might as well put that org-mode muscle memory to good use:
#+begin_src elisp
(map! :after python
      :map python-mode-map
      "C-c C-u" #'python-nav-backward-up-list)
#+end_src
*** TODO is this fennel config needed now that ~(doom! :lang (lua +fennel))~ exists?
#+begin_src elisp :tangle packages.el
(package! fennel-mode)
#+end_src

#+begin_src elisp
(use-package! fennel-mode
  :config (add-to-list 'auto-mode-alist '("\\.fnl\\'" . fennel-mode)))
#+end_src
*** graphql
#+begin_src elisp :tangle packages.el
(package! graphql-mode)
#+end_src

#+begin_src elisp
(use-package! graphql-mode)
#+end_src
*** elixir
#+begin_src elisp
(after! alchemist-mode
  (map! (:when (modulep! :lang elixir)    ; local conditional
          (:map alchemist-mode-map
           :localleader
           "tt" #'exunit-toggle-file-and-test
           "tT" #'exunit-toggle-file-and-test-other-window))))

#+end_src
*** yuck
#+begin_src elisp :tangle packages.el
(package! yuck-mode)
#+end_src
*** scheme, or: you've got gall, you've got guile [0/1]
Apologies to racket, which is a nicer language per se, but guile's already got its grubby
little +mitts+ C ABI in lots of interesting parts of the linux ecosystem and I just don't
have time to shop around. If the list stored at ~geiser-active-implementations~ has length >
1, then every time I restart emacs, I'll be prompted to choose which implementation to
associate with every. single. scheme. buffer. that. I. have. ever. opened. in. my. life.
It gets old fast:
#+begin_src elisp
(setq! geiser-active-implementations '(guile))
#+end_src

Guile's shebang convention is surprisingly well-considered from first principles, in terms
of how it relates to the rest of the language syntax and being a good cross-platform
citizen. It's also weird, complex, and idiosyncratic, and I am apparently incapable of
remembering it.

#+begin_src elisp
(defun insert-guile-shebang ()
  (interactive)
  (save-excursion
    (beginning-of-buffer)
    (insert
     (s-concat
      "#!"
      (or (executable-find
           (if (boundp 'amb/guile-executable-name)
               amb/guile-executable-name
             "guile"))
          "/usr/bin/guile")
      " \\
-e main -s
!#

"))))
#+end_src
**** TODO also define a fundamental-mode ~#!guile~ snippet for that shebang
*** yaml
#+begin_src elisp :tangle packages.el
(package! yaml-pro)
#+end_src

#+begin_src elisp
(use-package! yaml-pro
  :hook (yaml-mode . yaml-pro-mode)
  :hook (yaml-mode . yaml-pro-ts-mode)
  )
#+end_src

This was my OG config; it is not as nice as using a hook, and doesn't use the
tree-sitter-enabled version of ~yaml-pro-mode~. Here for reference, and because the
tree-sitter version requires a semi-manual setup step to install all the language servers.
#+begin_src elisp :tangle no
(use-package! yaml-pro
  :config (add-to-list 'auto-mode-alist '("\\.ya?ml'" . yaml-pro-mode)))
#+end_src
*** typst
#+begin_src elisp :tangle packages.el
(package! typst-mode)
(package! ox-typst)
#+end_src


#+begin_src elisp
;; Set up typst-mode to associate with .typ files
(use-package! typst-mode
  :mode ("\\.typ\\'" . typst-mode)
  :init
  ;; Optional: set your typst formatting command if you want to use it
  (setq typst-format-command "typst fmt"))

;; Load ox-typst for Org-mode export to Typst documents
(use-package! ox-typst
  :after org
  :config
  ;; Optional: any custom configuration for ox-typst here
  )

;; TODO add ox-typst to list of Org export backends
#+end_src
*** markdown and mdx
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
#+end_src
*** janet
#+begin_src elisp :tangle no :noweb-ref doom-modules-lang
(janet +tree-sitter)
#+end_src

and should I feel like playing a game of flycheckers:
#+begin_src elisp :tangle packages.el
(package! flycheck-janet
  :recipe '(:host github :repo "sogaiu/flycheck-janet" :files ("*.el")))

(package! ajrepl
  :recipe (:host github
           :repo "sogaiu/ajrepl"
           :files (:defaults ("ajrepl/"
                              "ajrepl/*"))))
#+end_src

#+begin_src elisp
(use-package! flycheck-janet)

(use-package! ajrepl
  :after janet-ts-mode
  :config
  (setq ajrepl-start-cmd-line '("janet" "-s" "-d"))

  (add-hook 'janet-ts-mode-hook
            #'ajrepl-interaction-mode)

  (defun +janet/open-repl ()
    (interactive)
    (ajrepl)
    (pop-to-buffer ajrepl-repl-buffer-name))
  (set-repl-handler! 'janet-ts-mode #'+janet/open-repl))
#+end_src
*** kdl config lang
#+begin_src elisp :tangle packages.el
(package! kdl-mode)
#+end_src

#+begin_src elisp
(use-package! kdl-mode
  :mode ("\\.kdl\\'" . kdl-mode))
#+end_src

** "I hear lisp is good for AI"
*** copilot
#+begin_src elisp :tangle no :noweb-ref default-toggles
(defvar amb/enable-copilot nil
  "Is my company paying for, and actively encouraging me to use, github copilot?")

#+end_src

#+begin_src elisp :tangle (if (boundp 'amb/enable-copilot) "packages.el" "no")
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
#+end_src

#+begin_src elisp :tangle (if (boundp 'amb/enable-copilot) "config.el" "no")
;; accept completion from copilot and fallback to company
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion-by-word)
              ("TAB" . 'copilot-accept-completion-by-word)
              ("C-TAB" . 'copilot-accept-completion)
              ("C-<tab>" . 'copilot-accept-completion)))
#+end_src
*** chatGPT
#+begin_src elisp :tangle packages.el
(package! gptel)
#+end_src

#+begin_src elisp
(use-package! gptel)
#+end_src
* {ma,}git
** the skeleton ~(after! magit ...)~ form specific config can be nowebbed into
:PROPERTIES:
:VISIBILITY: folded
:END:
#+begin_src elisp :noweb yes
(after! magit
  <<magit-window-management>>

  <<magit-auto-dash>>

  <<magit-sections>>

  <<magit-custom-actions>>

  <<magithub>>)
#+end_src

** magit status, like the cat in the hat, should clean up after itself
These are fine to set before magit is initialized, so they are directly tangled instead of injected into the ~after!~  block with noweb shenanigans.
#+begin_src elisp :tangle no :noweb-ref magit-window-management
  ;; strictly speaking unnecessary (it's the default)
  ;; (add-hook 'magit-pre-display-buffer-hook #'magit-save-window-configuration)
  (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
  (setq magit-bury-buffer-function #'magit-restore-window-configuration)
#+end_src

** If I can't type a space, why let me?
In scenarios like branch names, whitespace is disallowed. But using the spacebar as a word
separator is deep, deep muscle memory. Why fight it?
#+begin_src elisp :tangle no :noweb-ref magit-auto-dash
  (defun just-use-a-dash-instead-sheesh (_nope &rest _dontcare)
    (interactive)
    (self-insert-command 1 ?-))

  (advice-add 'magit-whitespace-disallowed :around #'just-use-a-dash-instead-sheesh)
#+end_src

** magit-status sections
#+begin_src elisp :tangle no :noweb-ref magit-sections
(setq! magit-section-initial-visibility-alist '((stashes . show) (commits . show)))
#+end_src

** custom actions in magit transients
#+begin_src elisp :tangle no :noweb-ref magit-custom-actions
(defun amb/magit-checkout-default-branch ()
  "Check out the default branch of the current repository."
  (interactive)
  (let ((default-branch (magit-git-string "rev-parse" "--abbrev-ref" "origin/HEAD")))
    (when default-branch
      ;; Strip the 'origin/' part from the branch name
      (let ((branch (replace-regexp-in-string "^origin/" "" default-branch)))
        ;; Checkout the branch using Magit
        (magit--checkout branch)
        (magit-refresh)))))

(transient-append-suffix 'magit-branch "b"
  '("M" "default branch" amb/magit-checkout-default-branch))
#+end_src

** working with dotfiles
I manage my dotfiles with a bare git repository; this takes a little extra effort to set
up properly. With a hat tip to [[https://github.com/hylophile/.files/blob/d2d41871bd6a74e4b55fadf44d46613d0bcacb53/.config/doom/config.org#dotfiles][hylo]], from whom much of this is adapted.

*** ~magit-status~
The song-and-dance is a two-step:
1) open ~magit-status~ for ~~/~ if no orthodox git repo can be found
2) advise ~magit-process-environment~ to set up the correct, unmatched values for ~GIT_WORK_TREE~ and ~GIT_DIR~ if and only if we're getting the status for the ~~/~ repo.

#+begin_src elisp
(defun amb/magit-status-with-dotfiles-fallback ()
  (interactive)
  (if (magit-gitdir)
      (magit-status)
    (magit-status "~/")))

(map! :after magit :leader "g g" #'amb/magit-status-with-dotfiles-fallback)

;; from https://github.com/magit/magit/issues/460

(defun amb/magit-process-environment (env)
  "Add GIT_DIR and GIT_WORK_TREE to ENV when in a special directory."
  (let ((here (file-name-as-directory (expand-file-name default-directory)))
        (home (expand-file-name "~/")))
    (when (string= here home)
      (let ((gitdir (expand-file-name "~/.dots/")))
        (push (format "GIT_WORK_TREE=%s" home) env)
        (push (format "GIT_DIR=%s" gitdir) env))))
  env)

(advice-add 'magit-process-environment
            :filter-return #'amb/magit-process-environment)

(defun amb/magit-stage-file ()
  (interactive)
  (if (magit-gitdir)
      (call-interactively #'magit-stage-file)
      (shell-command (concat
                      "git --git-dir=$HOME/.dots/ --work-tree=$HOME add "
                      (buffer-file-name))
                     t)))

(map! :after magit :leader "g S" #'amb/magit-stage-file)
#+end_src

*** ~projectile-find-file~
Without this, running projectile commands (on purpose or by accident) triggers an insane
cache-building odyssey in ~~/~; the fix is needed until magit can handle separate work trees
properly.

Doom recognizes my home directory as a git dir, but it doesn't find any of its config
whatsoever, which can cause projectile to act silly.

#+begin_src elisp :tangle no
(after! projectile (setq projectile-project-root-files-bottom-up (remove ".git"
projectile-project-root-files-bottom-up)))

(defun amb/projectile-find-file ()
  (interactive)
  (if (equal (expand-file-name "~/") (projectile-project-root))
    (call-interactively #'find-file)
    (projectile-find-file)))

(map! :leader "SPC" #'amb/projectile-find-file)
#+end_src

**** TODO filter candidate files to ~dots ls-files~

** nice git conflic resolution hydra
Gold standard, yes, but not be all and end all. This defines a nice hydra for working with
files containing git conflicts.

#+begin_src elisp
;; all thanks and apologies to https://github.com/alphapapa/unpackaged.el
(use-package! smerge-mode
  :after (hydra magit)
  :config
  (defhydra amb/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  (map! :leader :desc "resolve git conflicts" "gm" #'amb/smerge-hydra/body)
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (amb/smerge-hydra/body)))))
#+end_src

** working with github
#+begin_src elisp :tangle no :noweb-ref magithub
(defun amb/copy-github-permalink ()
  "Generate a GitHub permalink for the current file at the current revision (full SHA).
If a region is active, link to the highlighted line(s)."
  (interactive)
  (let* ((remote-url (magit-get "remote" (magit-get-remote) "url"))
         (repo-url (replace-regexp-in-string
                    (rx string-start
                        "git@"
                        (group (+ (not (any ":")))) ; match domain
                        ":"
                        (group (+ (not (any "."))))
                        (optional ".git")
                        string-end)
                    "https://\\1/\\2" remote-url))
         (full-sha (magit-rev-parse "HEAD"))
         (file-path (magit-file-relative-name buffer-file-name))
         (start-line (line-number-at-pos (region-beginning)))
         (end-line (line-number-at-pos (region-end)))
         (lines (if (use-region-p)
                    (if (= start-line end-line)
                        (format "#L%d" start-line)
                      (format "#L%d-L%d" start-line end-line))
                  ""))
         (permalink (format "%s/blob/%s/%s%s" repo-url full-sha file-path lines)))
    (copy-to-clipboard permalink)
    (message "GitHub permalink: %s" permalink)))
#+end_src

* info-mode, or: RTFM
#+begin_src elisp
(after! (evil evil-collection)
  (add-to-list '+evil-collection-disabled-list 'info)
  (set-evil-initial-state! 'info-mode 'emacs))

(map! :map 'info-mode-map
      "j" #'next-line
      "k" #'previous-line)
#+end_src
* org-mode config [0/1]
** drop it in a box
Notes must be at hand to be helpful, ideally on any of several computers:
#+begin_src elisp
(let ((dir "~/Dropbox/org/"))
  (and (file-exists-p dir)
       (setq org-directory dir)))
#+end_src

** make org-mode act nicer...
*** default overrides and TODOs
#+begin_src elisp
(setq! org-log-into-drawer t
       org-hierarchical-todo-statistics nil
       org-refile-use-outline-path 'full-file-path
       org-todo-keywords '((sequence "NEXT(n)" "TODO(t)" "BLOCKED(b)" "SOMEDAY(s)" "PROJ(p)" "QUESTION(q)" "|" "DONE(d)" "CANCELLED(c)")))
#+end_src

*** graphviz üìâ_(„ÉÑ)_üìà
#+begin_src elisp :tangle packages.el
(package! graphviz-dot-mode)
#+end_src

#+begin_src elisp
(use-package! graphviz-dot-mode
  :after org)
#+end_src
*** keybinding fixes
I wonder if this is a kkp/CSIu thing? i.e. org expects to receive ~(kbd "TAB")~ but instead gets ~(kbd "<tab>")~.

I also wonder if =kkp.el= or Henrik's adjustments atop it fix things for me?
#+begin_src elisp
(after! org
  (map! :after org
        :map 'org-mode-map
        "<tab>" #'org-cycle
        :nvie "C-M-S-RET" #'org-insert-todo-subheading
        :nvie "C-M-S-<return>" #'org-insert-todo-subheading
        :nvie "M-<return>" #'org-insert-heading)

  (defun my-org-mode-backtick-replacement ()
    "Replace a single backtick with = and triple backticks with a code block template."
    (interactive)
    (let ((context (buffer-substring-no-properties (max (point-min) (- (point) 2)) (point))))
      (if (string= context "==")
          (progn
            (delete-char -2)
            (insert "#+begin_src \n#+end_src\n")
            (forward-line -1)
            (move-beginning-of-line nil)
            (backward-char))
        (insert "="))))

  (defun my-org-mode-key-remap ()
    "Remap ` to custom function in org-mode."
    (local-set-key (kbd "`") 'my-org-mode-backtick-replacement))

  (add-hook 'org-mode-hook 'my-org-mode-key-remap))

#+end_src

*** export
#+begin_src elisp :tangle packages.el
(package! ox-gfm)
#+end_src

#+begin_src elisp
(use-package! ox-gfm
  :after org)

#+end_src

*** tangle
**** no noweb? no: noweb.
This snippet is taken directly from the org-mode info manual.
#+begin_src elisp
(after! org
  (setq! org-babel-default-header-args
        (cons '(:noweb . "yes")
              (assq-delete-all :noweb org-babel-default-header-args))))

#+end_src

** ...look nicer...
#+begin_src elisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))

(setq!
 org-hide-emphasis-markers t
 org-agenda-filter-preset '("-quotidian"))

(add-hook! (org-mode) (org-appear-mode 1))
#+end_src

*** optimize text presentation for reading and writing prose, not code
Olivetti is an emacs package which centers the buffer contents within margins clamped at
an appropriate width for reading, such that long, wrapped lines don't look like shit.
#+begin_src elisp :tangle packages.el
(package! olivetti)
#+end_src

Let's use =olivetti-mode= in all org buffers; and while I love line numbers in most cases,
it looks /very/ clean without them, so let's set that too:
#+begin_src elisp
(use-package! olivetti)

(after! (olivetti org)
  (defun amb/make-text-buffer-pretty ()
    (olivetti-mode 1)
    (setq-local display-line-numbers nil))

  (remove-hook 'text-mode-hook #'display-line-numbers-mode)
  (add-hook 'text-mode-hook #'amb/make-text-buffer-pretty)
  (add-hook 'org-mode-hook #'amb/make-text-buffer-pretty))
#+end_src

** ...and, like the buffalo, roam
First, I need a roam directory to serve as the "slipbox":
#+begin_src elisp
(setq org-roam-directory "~/Dropbox/roam/")
#+end_src

I'd like a pretty and interactive graph visualization, too, while I'm at it:
#+begin_src elisp
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

Org-roam-ui tries to keep up with the latest features of org-roam, which conflicts with Doom Emacs's desire for stability. To make sure nothing breaks, use the latest version of org-roam by unpinning it:
#+begin_src elisp :tangle packages.el
(unpin! org-roam)
(package! org-roam-ui)
#+end_src

** the yet-neglected agenda view
These values can be dynamically constructed by concatenating the values of
~org-roam-directory~ and ~org-roam-dailies-directory~; I did try to use those to make this
more future-proof, but that just passed along the unresolved symbol names (I assume
because ~setq~ is a macro) and everything went to heck.
#+begin_src elisp
(setq! org-agenda-files '("~/Dropbox/org/"
                          "~/Dropbox/roam/daily/"))

(defun org-my-auto-exclude-fn (tag)
  (if (cond
       ;; TODO show only the next 2
       ((string= tag "quotidian")
        t)
       ;; only see work things between 8am and 7pm
       ((string= tag "work")
        (let ((hr (nth 2 (decode-time))))
          (or (< hr 8) (> hr 19)))))
      (concat "-" tag)))

(setq org-agenda-auto-exclude-function 'org-my-auto-exclude-fn)

#+end_src

** outlines ‚ú® everywhere ‚ú®with outshine
#+begin_src elisp :tangle packages.el
(package! outshine
  :recipe (:host github :repo "alphapapa/outshine"))
#+end_src

#+begin_src elisp
(use-package! outshine
  :after org
  :config
  (add-hook 'prog-mode-hook 'outshine-mode))
#+end_src

** one statistics cookie to rule them all
Sometimes I want a bunch of independent top-level headings, but I also want a document-wide recursive todo statistics cookie. One way to achieve this is to define a named dynamic block, with a correspondingly-named function org uses to dynamically populate it when asked to (with =C-c C-c=, like most org actions).

*Caveats:*
- *nested checkboxes in todo headings break the count.* Very likely an org-mode bug.
- *You must have your cursor on a =BEGIN:= or =END:= line, /not/ the inner line with the dynamic cookie*. Org tries to handle actions on that with the ordinary statistics cookie logic, i.e. by querying its (nonexistent) heading context, so it always resolves to =[0/0]=.

With the following functions defined, org will know how to populate a block labeled like the following:
#+begin_src org-mode :tangle no
BEGIN: all-todo-stats
END:
#+end_src

You can type this out manually, but please also cf. the =<todos= snippet defined [[#todos-snippet][in this heading]].

*** implementation
:PROPERTIES:
:VISIBILITY: folded
:END:
#+begin_src elisp
;; should either of the following fns be wrapped in an `(after! org ...)` form?

(defun amb/org-todo-stats ()
  "Return statistics of TODO keywords in current buffer."
  (let ((todo-count 0)
        (done-count 0))
    (org-map-entries
     (lambda ()
       (let ((state (org-get-todo-state)))
         (when state
           (if (member state org-done-keywords)
               (cl-incf done-count)
             (cl-incf todo-count)))))
     t 'file)
    (format "[%d/%d]" done-count (+ todo-count done-count))))

(defun org-dblock-write:all-todo-stats (params)
  (insert (amb/org-todo-stats)))

#+end_src

* emacs is so great, why have just one?
#+begin_src elisp :tangle profiles.el
(
 <<emacs-profile-list>>
 )
#+end_src

** we don't /need/ to make doom the default, but if I make a CLI profile switcher it simplifies things
#+begin_src elisp :tangle no :noweb-ref emacs-profile-list
(default)
#+end_src

** nano emacs here I come
#+begin_src elisp :tangle no :noweb-ref emacs-profile-list
(nano (user-emacs-directory . "~/.config/emacsen/nano"))
#+end_src

* transient pop-up frames for externally-triggered one-of emacs actions
hat tip to [[https://protesilaos.com/codelog/2024-09-19-emacs-command-popup-frame-emacsclient/][Prot]]
** helpers to open/close popup frames
#+begin_src elisp
(defun amb/window-delete-popup-frame (&rest _)
  "Kill selected selected frame if it has parameter `amb-window-popup-frame'.
Use this function via a hook."
  (when (frame-parameter nil 'amb-window-popup-frame)
    (delete-frame)))

(defmacro amb/define-window-popup-command (command)
  "Define interactive function which calls COMMAND in a new frame.
Make the new frame have the `amb-window-popup-frame' parameter."
  `(defun ,(intern (format "amb/window-popup-%s" command)) ()
     ,(format "Run `%s' in a popup frame with `amb-window-popup-frame' parameter.
Also see `amb/window-delete-popup-frame'." command)
     (interactive)
     (let ((frame (make-frame '((amb-window-popup-frame . t)))))
       (select-frame frame)
       ;; buffers whose names start with a space char are considered hidden
       (switch-to-buffer " amb/window-hidden-buffer-for-popup-frame")
       (condition-case nil
           (call-interactively ',command)
         ((quit error user-error)
          (delete-frame frame))))))

#+end_src
*** TODO rewrite macro to take an optional hook argument for more self-contained/DWIM operation
If a hook is provided, the "close frame" function is added to the hook by the macro; else,
the "close frame" function is added to the command per se as ~:after~ advice
** popup frame commands
#+begin_src elisp
(after! org
  (amb/define-window-popup-command org-capture)
  (add-hook 'org-capture-after-finalize-hook #'amb/window-delete-popup-frame))

(advice-add 'copy-unicode-char-to-clipboard :after 'amb/window-delete-popup-frame)
(amb/define-window-popup-command copy-unicode-char-to-clipboard)
#+end_src
** for reference, here's Elken's simplified macOS adaptation
#+begin_src elisp :tangle no
  (defun popup-frame-delete (&rest _)
    "Kill selected frame if it has parameter `popup-frame'."
    (when-let ((bundle (frame-parameter nil 'bundle-identifier)))
      (ns-do-applescript (format "tell application id \"%s\" to activate" bundle)))
    (when (frame-parameter nil 'popup-frame)
      (delete-frame)))

  (defmacro popup-frame-define (command)
    "Define interactive function to call COMMAND in frame with TITLE."
    `(defun ,(intern (format "popup-frame-%s" command)) ()
       (interactive)
       (let* ((display-buffer-alist '(("")
                                      (display-buffer-full-frame)))
              (bundle-identifier (when IS-MAC
                                   (ns-do-applescript "tell application \"System Events\" to get bundle identifier of first process whose frontmost is true")))
              (frame (make-frame
                      `((title . ,(format "popup-frame-%s" ',command))
                        (window-system . ns)
                        (menu-bar-lines . 1)
                        (transient . t)
                        (height . 25)
                        (width . 70)
                        (popup-frame . t)
                        (bundle-identifier . ,bundle-identifier)))))
         (select-frame-set-input-focus frame)
         (switch-to-buffer " popup-frame-hidden-buffer")
         (condition-case nil
             (progn
               (call-interactively ',command)
               (delete-other-windows)
               (hide-mode-line-mode))
           ((quit error user-error)
            (progn
              (when bundle-identifier
                (ns-do-applescript (format "tell application id \"%s\" to activate" bundle-identifier)))
              (delete-frame frame)))))))
#+end_src

* appendices
** TODO uncategorized keybindings :: clean up
#+begin_src elisp
(map!
 :leader
 :desc "prior buffer" "=" #'evil-switch-to-windows-last-buffer
 "Nr" #'narrow-to-region
 "Nf" #'narrow-to-defun
 "Np" #'narrow-to-page
 "Ns" #'org-toggle-narrow-to-subtree
 "Nw" #'widen
 :desc "jump to first non-blank" "of" #'evil-first-non-blank
 :desc "new frame" "oF" #'make-frame
 :desc "Spell checker" "tS" #'spell-fu-mode
 :desc "Subword mode" "ts" #'subword-mode)

(map!
 "C-;" #'evil-avy-goto-char-timer
 :ni "C-)" #'sp-forward-slurp-sexp
 :ni "C-(" #'sp-backward-slurp-sexp
 (:when (not (display-graphic-p)) :map (evil-insert-state-map evil-motion-state-map) "C-z" #'suspend-frame))
#+end_src
*** TODO why can't I overwrite the =:desc= from the default spell checker binding on =SPC t s=?
** Who configures the configuration?
I do.

[a definitely very cool picture goes here eventually, probably]

*** whoami
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.

#+begin_src elisp
(setq user-full-name "Alex Birdsall"
      user-mail-address "ambirdsall@gmail.com")
#+end_src

*** shortcuts to open doom config file(s)
#+begin_src elisp
(map! :leader
      :desc "open doom config" "F" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
      :desc "open doom config" "fP" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
      :desc "open computer-specific doom config" "fL" (cmd! (find-file amb/computer-specific-config)))
#+end_src

*** what kind of spaceship doesn't come with a spedometer?
#+begin_src elisp :tangle no
(package! benchmark-init)
#+end_src

*** a literate config, tangled asynchronously
This is shamelessly lifted from [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur's config]]; since you seem to be the sort of
eccentric who reads emacs configs, odds are good that either you're already familiar with
it or you should be.

#+begin_src emacs-lisp :tangle no
(defvar +literate-tangle--proc nil)
(defvar +literate-tangle--proc-start-time nil)

(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (unless (getenv "__NOTANGLE")
    (let ((default-directory doom-private-dir))
      (when +literate-tangle--proc
        (message "Killing outdated tangle process...")
        (set-process-sentinel +literate-tangle--proc #'ignore)
        (kill-process +literate-tangle--proc)
        (sit-for 0.3)) ; ensure the message is seen for a bit
      (setq +literate-tangle--proc-start-time (float-time)
            +literate-tangle--proc
            (start-process "tangle-config"
                           (get-buffer-create " *tangle config*")
                           "emacs" "--batch" "--eval"
                           (format "(progn \
(require 'ox) \
(require 'ob-tangle) \
(setq org-confirm-babel-evaluate nil \
      org-inhibit-startup t \
      org-mode-hook nil \
      write-file-functions nil \
      before-save-hook nil \
      after-save-hook nil \
      vc-handled-backends nil \
      org-startup-folded nil \
      org-startup-indented nil) \
(org-babel-tangle-file \"%s\" \"%s\"))"
                                   +literate-config-file
                                   (expand-file-name doom-module-config-file))))
      (set-process-sentinel +literate-tangle--proc #'+literate-tangle--sentinel)
      (run-at-time nil nil (lambda () (message "Tangling config.org"))) ; ensure shown after a save message
      "Tangling config.org...")))

(defun +literate-tangle--sentinel (process signal)
  (cond
   ((and (eq 'exit (process-status process))
         (= 0 (process-exit-status process)))
    (message "Tangled config.org sucessfully (took %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))
   ((memq (process-status process) (list 'exit 'signal))
    (pop-to-buffer (get-buffer " *tangle config*"))
    (message "Failed to tangle config.org (after %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))))

(defun +literate-tangle-check-finished ()
  (when (and (process-live-p +literate-tangle--proc)
             (yes-or-no-p "Config is currently retangling, would you please wait a few seconds?"))
    (switch-to-buffer " *tangle config*")
    (signal 'quit nil)))
(add-hook! 'kill-emacs-hook #'+literate-tangle-check-finished)

#+end_src

** top-of-file preambles
*** packages.el
#+begin_src elisp :tangle no :noweb-ref packages-preamble
;; -*- no-byte-compile: t; -*-

#+end_src

*** config.el
#+begin_src elisp :tangle no :noweb-ref config-preamble
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; commentary: what the fuck

#+end_src

*** init.el
#+begin_src elisp :tangle no :noweb-ref init-preamble
;;; init.el -*- lexical-binding: t; -*-
#+end_src

** The secrets I keep with myself, or: praise the Lord and pass the =.gitignore=
In general, I would like my config to travel with me from computer to computer: this
streamlines maintaining old but still functioning laptops, work-provided computers, etc.
But there are some exceptions: maybe an older laptop needs a small hack to work around a
strange bug, or maybe my job provides an account for some proprietary bit of tooling that
should only run while I'm actually working that job; for those, I support a few
computer-specific config files, to be loaded if present:
- =local-toggles.el= is loaded very early in my config; its primary purpose is setting toggles
  so I can define configuration for opt-in features, which are only enabled on a
  computer-by-computer basis.
- =local-config.el= is loaded last, giving me a convenient place for ad hoc overrides of any
  setting in here.
*** define vars for local config files for future reference
#+begin_src elisp :noweb-ref config-preamble
(defvar amb/computer-specific-config (expand-file-name "local-config.el" doom-private-dir)
  "A file for computer-specific config and overrides, hidden from git; for example,
configuration for a work computer and its (possibly private) product projects.")

(defvar amb/computer-specific-toggles (expand-file-name "local-toggles.el" doom-private-dir)
  "A file for {en,dis}abling configuration and features on a computer-specific basis,
hidden from git; for example, configuration for proprietary
features enabled for a work computer by a company account.")
#+end_src

*** load file with local overrides if present
#+begin_src elisp :noweb-ref load-local-toggle-overrides
(if (file-exists-p amb/computer-specific-toggles)
      (load amb/computer-specific-toggles))
#+end_src

#+begin_src elisp :noweb-ref config-epilogue
(if (file-exists-p amb/computer-specific-config)
      (load amb/computer-specific-config))
#+end_src
** text manipulation utility macros
Working with text combines a huge variety of content-specific considerations with a very
narrow, consistent API; there are a lot of repetitive definitions. Let's improve that:
#+begin_src elisp :tangle no :noweb-ref text-manipulation-metafns
(defmacro cmds--on-string-or-region (fn)
  "Given a string-manipulation function FN, defines an interactive command which will apply that
function to either a string argument or to selected text, depending on context."
  `(lambda (string &optional from to)
     (interactive
      (if (use-region-p)
          (list nil (region-beginning) (region-end))
        (let ((bds (bounds-of-thing-at-point 'sexp)))
          (list nil (car bds) (cdr bds)))))

     (let* ((work-on-string? (if string t nil))
            (input-str (if work-on-string?
                           string
                         (buffer-substring-no-properties from to)))
            (output-str (funcall ,fn input-str)))

       (if work-on-string?
           output-str
         (save-excursion
           (delete-region from to)
           (goto-char from)
           (insert output-str))))))

(defmacro def-text-transform (name fn &optional docstring)
  "Create a new interactive command bound to NAME using some
string manipulation function FN. It will work given a string
argument programmatically or by operating on selected text when
used interactively."
  `(defalias ,name (cmds--on-string-or-region ,fn) ,docstring))
#+end_src

* Footnotes

[fn:1] This is the white-on-white crime our politicians /should/ be talking about, if you ask me.

#+begin_src elisp :noweb yes
<<config-epilogue>>
#+end_src

# Local Variables:
# org-indent-mode: nil
# End:
