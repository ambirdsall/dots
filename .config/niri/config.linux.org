#+title: Niri config

* intro and bookkeeping
#+begin_src elisp :results none
(org-babel-tangle-file (buffer-file-name))
#+end_src

#+begin_src elisp :results none
(add-hook! 'after-save-hook :local
  (org-babel-tangle-file (buffer-file-name)))
#+end_src

Goddamn it, another tiling WM sucked me in lol.

This time, though, I can (and enthusiastically do) delegate the whole "build a functioning
desktop environment around the window management" thing. Chapeau, [[https://github.com/AvengeMedia/DankMaterialShell/][DankMaterialShell]].

- This config is in [[https://kdl.dev][the KDL format]]
- =/-= comments out the following node.
- c.f. [[https://yalter.github.io/niri/Configuration:-Introduction][niri's GH wiki]] for a full description of the configuration

* Input device configuration.
Find the full list of options on the wiki:
 https://yalter.github.io/niri/Configuration:-Input
#+begin_src kdl :tangle config.kdl
input {
#+end_src
** keyboard
#+begin_src kdl :tangle config.kdl
    keyboard {
        xkb {
            // You can set rules, model, layout, variant and options.
            // For more information, see xkeyboard-config(7).

            // For example:
            // layout "us,ru"
            // options "grp:win_space_toggle,compose:ralt,ctrl:nocaps"

            // If this section is empty, niri will fetch xkb settings
            // from org.freedesktop.locale1. You can control these using
            // localectl set-x11-keymap.
        }

        // Enable numlock on startup, omitting this setting disables it.
        numlock
    }
#+end_src
** pointing devices
#+begin_src kdl :tangle config.kdl

    // Next sections include libinput settings.
    // Omitting settings disables them, or leaves them at their default values.
    // All commented-out settings here are examples, not defaults.
    touchpad {
        dwt
        click-method "clickfinger"
        // accel-speed 0.2
        // accel-profile "flat"
        // disabled-on-external-mouse
    }

    mouse {
        // off
        // natural-scroll
        // accel-speed 0.2
        // accel-profile "flat"
        // scroll-method "no-scroll"
    }

    trackpoint {
        // off
        // natural-scroll
        // accel-speed 0.2
        // accel-profile "flat"
        // scroll-method "on-button-down"
        // scroll-button 273
        // scroll-button-lock
        // middle-emulation
    }

    // Uncomment this to make the mouse warp to the center of newly focused windows.
    // warp-mouse-to-focus

    // Focus windows and outputs automatically when moving the mouse into them.
    // Setting max-scroll-amount="0%" makes it work only on windows already fully on screen.
    // focus-follows-mouse max-scroll-amount="0%"
}

#+end_src

* output :: monitor-specific config
You can configure outputs by their name, which you can find
by running `niri msg outputs` while inside a niri instance.
The built-in laptop monitor is usually called "eDP-1".
Find more information on the wiki: https://yalter.github.io/niri/Configuration:-Outputs

#+begin_src :tangle no
â”Œ ~ ðŸŒ—
â””âž£ niri msg outputs | rg -S 'Output|Logical size|current'
Output "AU Optronics 0xD291 Unknown" (eDP-1)
  Logical size: 1536x960
    1920x1200@60.026 (current, preferred)
Output "Acer Technologies SB220Q 0x11102304" (DP-6)
  Logical size: 1920x1080
    1920x1080@74.973 (current, preferred)
Output "Dell Inc. DELL U2722D 3W06FH3" (DP-5)
  Logical size: 2560x1440
    2560x1440@59.951 (current, preferred)

#+end_src

#+NAME: laptop-screen-width
#+begin_src bash :tangle no :results tangle
niri msg outputs | rg -A 5 eDP-1 | awk '/Logical size:/ { split($3,a,"x"); print a[1] }' | tr -d "\n"
#+end_src


#+begin_src kdl :tangle config.kdl
// laptop monitor in the middle
// i.e. at origin
// the y=300 bit is accounting for the lower height of the laptop stand vs the monitor stands
output "eDP-1" {
    position x=0 y=300
}

// acer monitor to the left
// i.e. shifted its own width left of origin
// Logical size: 1920x1080
output "DP-6" {
    position x=-1920 y=0
}

// dell monitor to the right
// i.e. shifted the *laptop* monitor's width to the right
// Logical size: 2560x1440
output "DP-5" {
    position x=<<laptop-screen-width()>> y=-80
}
#+end_src

** TODO dynamic/portable calculations of laptop-screen-size-based ~y=~ values

* layout and UI
Settings that influence how windows are positioned and sized.
Find more information on the wiki: https://yalter.github.io/niri/Configuration:-Layout
#+begin_src kdl :tangle config.kdl
layout {
    <<layout>>
}
#+end_src
** window frames: gaps, focus ring, etc
*** gaps
Gaps around windows are defined in logical pixels.
#+begin_src kdl :tangle no :noweb-ref layout
gaps 8
#+end_src

*** focus ring
By default focus ring and border are rendered as a solid background rectangle
behind windows. That is, they will show up through semitransparent windows.
This is because windows using client-side decorations can have an arbitrary shape.

If you don't like that, you should uncomment `prefer-no-csd` below.
Niri will draw focus ring and border *around* windows that agree to omit their
client-side decorations.

Alternatively, you can override it with a window rule called
=draw-border-with-background=.

Colors can be set in a variety of ways:
- CSS named colors: =red=
- RGB hex: =#rgb=, =#rgba=, =#rrggbb=, =#rrggbbaa=
- CSS-like notation: =rgb(255, 127, 0)=, =rgba()=, =hsl()= and a few others.

#+begin_src kdl :tangle no :noweb-ref layout
focus-ring {
    width 3

    // Color of the ring on the active monitor.
    active-color "#7fc8ff"

    // Color of the ring on inactive monitors.
    //
    // The focus ring only draws around the active window, so the only place
    // where you can see its inactive-color is on other monitors.
    inactive-color "#505050"

    // You can also use gradients. They take precedence over solid colors.
    // Gradients are rendered the same as CSS linear-gradient(angle, from, to).
    // The angle is the same as in linear-gradient, and is optional,
    // defaulting to 180 (top-to-bottom gradient).
    // You can use any CSS linear-gradient tool on the web to set these up.
    // Changing the color space is also supported, check the wiki for more info.
    //
    active-gradient from="#80c8ff" to="#c7ff7f" angle=45

    // You can also color the gradient relative to the entire view
    // of the workspace, rather than relative to just the window itself.
    // To do that, set relative-to="workspace-view".
    //
    // inactive-gradient from="#505050" to="#808080" angle=45 relative-to="workspace-view"
}

#+end_src
*** border
You can also add a border. It's similar to the focus ring, but always visible.
The settings are the same as for the focus ring.
If you enable the border, you probably want to disable the focus ring.
Gradients can use a few different interpolation color spaces.
For example, this is a pastel rainbow gradient via ~in="oklch longer hue"~:
#+begin_src kdl :tangle no
active-gradient from="#e5989b" to="#ffb4a2" angle=45 relative-to="workspace-view" in="oklch longer hue"
inactive-gradient from="#505050" to="#808080" angle=45 relative-to="workspace-view"
#+end_src

#+begin_src kdl :tangle no
border {
    off

    width 4
    active-color "#ffc87f"
    inactive-color "#505050"

    // Color of the border around windows that request your attention.
    urgent-color "#9b0000"
}

#+end_src
*** struts : they : CSS padding :: gaps : CSS margin
Struts shrink the area occupied by windows, similarly to layer-shell panels.  You can
think of them as a kind of outer gaps. They are set in logical pixels.  Left and right
struts will cause the next window to the side to always be visible.  Top and bottom struts
will simply add outer gaps in addition to the area occupied by layer-shell panels and
regular gaps.

#+begin_src kdl :tangle no
struts {
    left 64
    right 64
    top 64
    bottom 64
}
#+end_src

#+begin_src kdl :tangle no :noweb-ref layout
struts {}
#+end_src
** tiling behavior :: Â¿center? on focus, preset sizes, etc
When to center a column when changing focus, options are:
- "never" :: default behavior, focusing an off-screen column will keep at the left
  or right edge of the screen.
- "always" :: the focused column will always be centered.
- "on-overflow" :: focusing a column will center it if it doesn't fit
  together with the previously focused column.
#+begin_src kdl :tangle no :noweb-ref layout
center-focused-column "never"
// center-focused-column "always"
// center-focused-column "on-overflow"

// You can customize the widths that "switch-preset-column-width" (Mod+R) toggles between.
preset-column-widths {
    // Proportion sets the width as a fraction of the output width, taking gaps into account.
    // For example, you can perfectly fit four windows sized "proportion 0.25" on an output.
    // The default preset widths are 1/3, 1/2 and 2/3 of the output.
    proportion 0.33333
    proportion 0.5
    proportion 0.66667
    proportion 0.99999

    // Fixed sets the width in logical pixels exactly.
    // fixed 1920
}

// You can also customize the heights that "switch-preset-window-height" (Mod+Shift+R) toggles between.
preset-window-heights {
    proportion 0.33333
    proportion 0.5
    proportion 0.66667
    proportion 0.99999
}

// You can change the default width of the new windows.
// default-column-width { proportion 0.5; }
// If you leave the brackets empty, the windows themselves will decide their initial width.
default-column-width {}

#+end_src
** drop shadows
You can enable drop shadows for windows.
#+begin_src kdl :tangle no
shadow {
    // Uncomment the next line to enable shadows.
    // on

    // By default, the shadow draws only around its window, and not behind it.
    // Uncomment this setting to make the shadow draw behind its window.
    //
    // Note that niri has no way of knowing about the CSD window corner
    // radius. It has to assume that windows have square corners, leading to
    // shadow artifacts inside the CSD rounded corners. This setting fixes
    // those artifacts.
    //
    // However, instead you may want to set prefer-no-csd and/or
    // geometry-corner-radius. Then, niri will know the corner radius and
    // draw the shadow correctly, without having to draw it behind the
    // window. These will also remove client-side shadows if the window
    // draws any.
    //
    // draw-behind-window true

    // You can change how shadows look. The values below are in logical
    // pixels and match the CSS box-shadow properties.

    // Softness controls the shadow blur radius.
    softness 30

    // Spread expands the shadow.
    spread 5

    // Offset moves the shadow relative to the window.
    offset x=0 y=5

    // You can also change the shadow color and opacity.
    color "#0007"
}

#+end_src
** hotkey-overlay
Don't show it at startup:
#+begin_src kdl :tangle config.kdl
hotkey-overlay {
    // Uncomment this line to disable the "Important Hotkeys" pop-up at startup.
    skip-at-startup
}

#+end_src

But /do/ show it if I type =Mod+?=:
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Shift+Slash { show-hotkey-overlay; }
#+end_src
** screenshot path
You can change the path where screenshots are saved.
A =~= at the front will be expanded to the home directory.
The path is formatted with =strftime(3)= to give you the screenshot date and time.

You can also set this to null to disable saving screenshots to disk, e.g. =screenshot-path null=

#+begin_src kdl :tangle config.kdl
screenshot-path "~/screenshots/%Y-%m-%d_%H-%M-%S_screenshot.png"

#+end_src
** Animation settings.
The wiki explains how to configure individual animations: https://yalter.github.io/niri/Configuration:-Animations

I do like the animations, but Rocinante, my old 8GB RAM macbook, struggles with them; so
we must mind system constraints when tangling this subsection. On linux, =/proc/meminfo=
will return info including a =MemTotal= line listing how many 1024-byte blocks of memory are
available; I'm hacking around a problem for a single, solitary old grey mare, whose total
just clears 8 million of them: this leaves us with 8,888,888 as the smallest
aesthetically-pleasing magic number to compare against.

#+name: has-the-horsies
#+begin_src sh :tangle no :results tangle
if [ $(echo "$(awk '/MemTotal/ { print $2}' /proc/meminfo) > 8888888" | bc) -eq 1 ]; then
    echo "// this computer has the horsies"
else
    echo off
fi
#+end_src

#+begin_src kdl :tangle config.kdl
animations {
    <<has-the-horsies()>>
}

#+end_src
* spawn processes at startup
To run a shell command (with variables, pipes, etc.), use spawn-sh-at-startup, e.g. =spawn-sh-at-startup "qs -c ~/source/qs/MyAwesomeShell"=

#+begin_src kdl :tangle config.kdl
// BEGIN DMS STARTUP SHIT
// Required for clipboard history integration
spawn-at-startup "bash" "-c" "wl-paste --watch cliphist store &"

// Starts DankShell
spawn-at-startup "dms" "run"

spawn-at-startup "/usr/libexec/mate-polkit/polkit-mate-authentication-agent-1"

config-notification {
    disable-failed
}
// END DMS STARTUP SHIT

#+end_src

* named workspaces
Here are the workspaces I always want to have around and named:

#+begin_src kdl :tangle config.kdl
workspace "home base"
workspace "jorb"
workspace "website and resume"
workspace "computer project du jour"
workspace "watching shit"
workspace "chess"
workspace "C.R.E.A.M."
#+end_src

Now let's make it nice to work with them.

** working with named workspaces
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+W hotkey-overlay-title="Focus named workspace" { spawn "~/bin/niri-helper" "focus"; }
Mod+Ctrl+W hotkey-overlay-title="Move column to named workspace" { spawn "~/bin/niri-helper" "move-column"; }
#+end_src

#+begin_src janet-ts :tangle ~/bin/niri-helper :shebang "#!/usr/bin/env janet"
(use sh)
(import spork/json)

(defn- choose-other-workspace! [title]
  (let [other-workspaces (->> (json/decode ($<_ niri msg --json workspaces))
                              (filter |(and (not (get $ "is_focused"))
                                            (string? (get $ "name"))))
                              (map |(get $ "name")))
        choices (string/join (interpose "\n" other-workspaces))
        prompt (string/join [title ": "])]
    ($<_ echo ,choices | fuzzel --dmenu --use-bold --prompt-color ,"008853ff" --prompt ,prompt)))

(defn- focus-workspace []
  (let [selection (choose-other-workspace! "Go to workspace")]
    ($ niri msg action focus-workspace ,selection)))

(defn- move-column-to-workspace []
  (let [selection (choose-other-workspace! "Move column to workspace")]
    ($ niri msg action move-column-to-workspace ,selection)))

(defn main [& invocation]
  (match invocation
    [_ "move-column"] (move-column-to-workspace)
    [_ "focus"] (focus-workspace)
    [_] (error "I don't know what the fuck to do if you don't fucking tell me what to do")))
#+end_src

** TODO display workspace names in the dms top bar workspaces lists
For the time being, manually defining icons for all named workspaces in the DMS settings dashboard
will have to do.

* window rules
Window rules let you adjust behavior for individual windows.
Find more information on the wiki: https://yalter.github.io/niri/Configuration:-Window-Rules

Work around WezTerm's initial configure bug
by setting an empty default-column-width.
#+begin_src kdl :tangle config.kdl
window-rule {
    // This regular expression is intentionally made as specific as possible,
    // since this is the default config, and we want no false positives.
    // You can get away with just app-id="wezterm" if you want.
    match app-id=r#"^org\.wezfurlong\.wezterm$"#
    default-column-width {}
}

// Open the Firefox picture-in-picture player as floating by default.
window-rule {
    // This app-id regular expression will work for both:
    // - host Firefox (app-id is "firefox")
    // - Flatpak Firefox (app-id is "org.mozilla.firefox")
    match app-id=r#"firefox$"# title="^Picture-in-Picture$"
    open-floating true
}

// Example: block out two password managers from screen capture.
// (This example rule is commented out with a "/-" in front.)
/-window-rule {
    match app-id=r#"^org\.keepassxc\.KeePassXC$"#
    match app-id=r#"^org\.gnome\.World\.Secrets$"#

    block-out-from "screen-capture"

    // Use this instead if you want them visible on third-party screenshot tools.
    // block-out-from "screencast"
}

// Example: enable rounded corners for all windows.
// (This example rule is commented out with a "/-" in front.)
/-window-rule {
    geometry-corner-radius 12
    clip-to-geometry true
}

#+end_src
* keybinds
Keys consist of modifiers separated by + signs, followed by an XKB key name
in the end. To find an XKB name for a particular key, you may use a program
like wev.

"Mod" is a special modifier equal to Super when running on a TTY, and to Alt
when running as a winit window.

Most actions that you can bind here can also be invoked programmatically with
=niri msg action do-something=.

This one is big, so let's break it out into sections. We'll noweb them all into a skeleton
block so the closing brace isn't dangling or forgotten.
#+begin_src kdl :tangle config.kdl
binds {
    <<keybinds>>
}
#+end_src

** DankMaterialShell integration
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Space hotkey-overlay-title="Application Launcher" {
    spawn "dms" "ipc" "call" "spotlight" "toggle";
}
Mod+V hotkey-overlay-title="Clipboard Manager" {
    spawn "dms" "ipc" "call" "clipboard" "toggle";
}
Mod+M hotkey-overlay-title="Task Manager" {
    spawn "dms" "ipc" "call" "processlist" "toggle";
}
Mod+N hotkey-overlay-title="Notification Center" {
    spawn "dms" "ipc" "call" "notifications" "toggle";
}
Mod+Shift+P hotkey-overlay-title="Settings" {
    spawn "dms" "ipc" "call" "settings" "toggle";
}
Mod+P hotkey-overlay-title="Notepad" {
    spawn "dms" "ipc" "call" "notepad" "toggle";
}
Super+Alt+L hotkey-overlay-title="Lock Screen" {
    spawn "dms" "ipc" "call" "lock" "lock";
}
Mod+X hotkey-overlay-title="Power Menu" {
    spawn "dms" "ipc" "call" "powermenu" "toggle";
}
XF86AudioRaiseVolume allow-when-locked=true {
    spawn "dms" "ipc" "call" "audio" "increment" "3";
}
XF86AudioLowerVolume allow-when-locked=true {
    spawn "dms" "ipc" "call" "audio" "decrement" "3";
}
XF86AudioMute allow-when-locked=true {
    spawn "dms" "ipc" "call" "audio" "mute";
}
XF86AudioMicMute allow-when-locked=true {
    spawn "dms" "ipc" "call" "audio" "micmute";
}
XF86MonBrightnessUp allow-when-locked=true {
    spawn "dms" "ipc" "call" "brightness" "increment" "5" "";
}
// You can override the default device for e.g. keyboards by adding the device name to the last param
XF86MonBrightnessDown allow-when-locked=true {
    spawn "dms" "ipc" "call" "brightness" "decrement" "5" "";
}
// Night mode toggle
Mod+Shift+N allow-when-locked=true {
    spawn "dms" "ipc" "call" "night" "toggle";
}

#+end_src

** hotkeys to open windows
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Return hotkey-overlay-title="Open a Terminal: kitty" { spawn "kitty"; }
Mod+T hotkey-overlay-title="Open a Terminal: alacritty" { spawn "alacritty"; }
Mod+D { spawn "fuzzel"; }

#+end_src
** navigating, herding, and culling windows/columns
*** the person who makes the sentence should swing the sword
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Q repeat=false { close-window; }

#+end_src
*** windows/columns within a workspace
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Left  { focus-column-left; }
Mod+Down  { focus-window-down; }
Mod+Up    { focus-window-up; }
Mod+Right { focus-column-right; }
Mod+H     { focus-column-left; }
Mod+J     { focus-window-down; }
Mod+K     { focus-window-up; }
Mod+L     { focus-column-right; }

Mod+Ctrl+Left  { move-column-left; }
Mod+Ctrl+Down  { move-window-down; }
Mod+Ctrl+Up    { move-window-up; }
Mod+Ctrl+Right { move-column-right; }
Mod+Ctrl+H     { move-column-left; }
Mod+Ctrl+J     { move-window-down; }
Mod+Ctrl+K     { move-window-up; }
Mod+Ctrl+L     { move-column-right; }

Mod+Home { focus-column-first; }
Mod+End  { focus-column-last; }
Mod+Ctrl+Home { move-column-to-first; }
Mod+Ctrl+End  { move-column-to-last; }

#+end_src
*** moving focus or window(s) between monitors
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Shift+Left  { focus-monitor-left; }
Mod+Shift+Down  { focus-monitor-down; }
Mod+Shift+Up    { focus-monitor-up; }
Mod+Shift+Right { focus-monitor-right; }
Mod+Shift+H     { focus-monitor-left; }
Mod+Shift+J     { focus-monitor-down; }
Mod+Shift+K     { focus-monitor-up; }
Mod+Shift+L     { focus-monitor-right; }

Mod+Shift+Ctrl+Left  { move-column-to-monitor-left; }
Mod+Shift+Ctrl+Down  { move-column-to-monitor-down; }
Mod+Shift+Ctrl+Up    { move-column-to-monitor-up; }
Mod+Shift+Ctrl+Right { move-column-to-monitor-right; }
Mod+Shift+Ctrl+H     { move-column-to-monitor-left; }
Mod+Shift+Ctrl+J     { move-column-to-monitor-down; }
Mod+Shift+Ctrl+K     { move-column-to-monitor-up; }
Mod+Shift+Ctrl+L     { move-column-to-monitor-right; }
#+end_src

Alternatively, there are commands to move just a single window, e.g.
#+begin_src kdl :tangle no
Mod+Shift+Ctrl+Left  { move-window-to-monitor-left; }
#+end_src
But in the common case there's no difference; in the "big stack" degenerate case column
saves a hassle; and when that window-specific precision /is/ needed, you can use  =Mod+]= or
=Mod+[= to move a becolumned window out of its stack before the monitor swap to achieve the
same thing.

#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Shift+Ctrl+Alt+Left  { move-workspace-to-monitor-left; }
Mod+Shift+Ctrl+Alt+H  { move-workspace-to-monitor-left; }
Mod+Shift+Ctrl+Alt+Right  { move-workspace-to-monitor-right; }
Mod+Shift+Ctrl+Alt+L  { move-workspace-to-monitor-right; }
#+end_src
*** traversing the workspace list
It is an inherently vertical list, mind you.

#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Grave { focus-workspace-previous; }

Mod+Page_Down      { focus-workspace-down; }
Mod+Page_Up        { focus-workspace-up; }
Mod+U              { focus-workspace-down; }
Mod+I              { focus-workspace-up; }
Mod+Ctrl+Page_Down { move-column-to-workspace-down; }
Mod+Ctrl+Page_Up   { move-column-to-workspace-up; }
Mod+Ctrl+U         { move-column-to-workspace-down; }
Mod+Ctrl+I         { move-column-to-workspace-up; }

// Alternatively, there are commands to move just a single window:
// Mod+Ctrl+Page_Down { move-window-to-workspace-down; }
// ...

Mod+Shift+Page_Down { move-workspace-down; }
Mod+Shift+Page_Up   { move-workspace-up; }
Mod+Shift+U         { move-workspace-down; }
Mod+Shift+I         { move-workspace-up; }

#+end_src
*** addressing workspaces by index
You can refer to workspaces by index. However, keep in mind that
niri is a dynamic workspace system, so these commands are kind of
"best effort". Trying to refer to a workspace index bigger than
the current workspace count will instead refer to the bottommost
(empty) workspace.

For example, with 2 workspaces + 1 empty, indices 3, 4, 5 and so on
will all refer to the 3rd workspace.
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+1 { focus-workspace 1; }
Mod+2 { focus-workspace 2; }
Mod+3 { focus-workspace 3; }
Mod+4 { focus-workspace 4; }
Mod+5 { focus-workspace 5; }
Mod+6 { focus-workspace 6; }
Mod+7 { focus-workspace 7; }
Mod+8 { focus-workspace 8; }
Mod+9 { focus-workspace 9; }
Mod+Ctrl+1 { move-column-to-workspace 1; }
Mod+Ctrl+2 { move-column-to-workspace 2; }
Mod+Ctrl+3 { move-column-to-workspace 3; }
Mod+Ctrl+4 { move-column-to-workspace 4; }
Mod+Ctrl+5 { move-column-to-workspace 5; }
Mod+Ctrl+6 { move-column-to-workspace 6; }
Mod+Ctrl+7 { move-column-to-workspace 7; }
Mod+Ctrl+8 { move-column-to-workspace 8; }
Mod+Ctrl+9 { move-column-to-workspace 9; }

#+end_src

There are commands to move just a single window, e.g.
#+begin_src kdl :tangle no
Mod+Ctrl+1 { move-window-to-workspace 1; }
#+end_src
*** working with columns/vertical stacks
The following binds move the focused window in and out of a column.
If the window is alone, they will consume it into the nearby column to the side.
If the window is already in a column, they will expel it out.

#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+BracketLeft  { consume-or-expel-window-left; }
Mod+BracketRight { consume-or-expel-window-right; }
#+end_src

Consume one window from the right to the bottom of the focused column.
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Comma  { consume-window-into-column; }
#+end_src

Expel the bottom window from the focused column to the right.
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Period { expel-window-from-column; }
#+end_src

#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+R { switch-preset-column-width; }
Mod+Alt+R { switch-preset-column-width-back; }
Mod+Shift+R { switch-preset-window-height; }
Mod+Alt+Shift+R { switch-preset-window-height-back; }
Mod+Ctrl+R { reset-window-height; }
#+end_src

=expand-column-to-available-width= expands the focused column to space not taken up by other fully visible columns;/ makes the column "fill the rest of the space".
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+F { maximize-column; }
Mod+Shift+F { fullscreen-window; }

Mod+Ctrl+F { expand-column-to-available-width; }

#+end_src

Center a column, or all fully visible columns, on screen.
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+C { center-column; }

Mod+Ctrl+C { center-visible-columns; }

#+end_src
*** the mouse and trackwheel versions of that shit
#+begin_src kdl :tangle no :noweb-ref keybinds
// You can bind mouse wheel scroll ticks using the following syntax.
// These binds will change direction based on the natural-scroll setting.
//
// To avoid scrolling through workspaces really fast, you can use
// the cooldown-ms property. The bind will be rate-limited to this value.
// You can set a cooldown on any bind, but it's most useful for the wheel.
Mod+WheelScrollDown      cooldown-ms=150 { focus-workspace-down; }
Mod+WheelScrollUp        cooldown-ms=150 { focus-workspace-up; }
Mod+Ctrl+WheelScrollDown cooldown-ms=150 { move-column-to-workspace-down; }
Mod+Ctrl+WheelScrollUp   cooldown-ms=150 { move-column-to-workspace-up; }

Mod+WheelScrollRight      { focus-column-right; }
Mod+WheelScrollLeft       { focus-column-left; }
Mod+Ctrl+WheelScrollRight { move-column-right; }
Mod+Ctrl+WheelScrollLeft  { move-column-left; }

// Usually scrolling up and down with Shift in applications results in
// horizontal scrolling; these binds replicate that.
Mod+Shift+WheelScrollDown      { focus-column-right; }
Mod+Shift+WheelScrollUp        { focus-column-left; }
Mod+Ctrl+Shift+WheelScrollDown { move-column-right; }
Mod+Ctrl+Shift+WheelScrollUp   { move-column-left; }

// Similarly, you can bind touchpad scroll "ticks".
// Touchpad scrolling is continuous, so for these binds it is split into
// discrete intervals.
// These binds are also affected by touchpad's natural-scroll, so these
// example binds are "inverted", since we have natural-scroll enabled for
// touchpads by default.
// Mod+TouchpadScrollDown { spawn-sh "wpctl set-volume @DEFAULT_AUDIO_SINK@ 0.02+"; }
// Mod+TouchpadScrollUp   { spawn-sh "wpctl set-volume @DEFAULT_AUDIO_SINK@ 0.02-"; }

#+end_src
** overview
Open/close the Overview: a zoomed-out view of workspaces and windows.
You can also move the mouse into the top-left hot corner, or do a four-finger swipe up on
a touchpad.
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+O repeat=false { toggle-overview; }

#+end_src
** defaults and sundry
Finer width adjustments. This command can also:
- set width in pixels: "1000"
- adjust width in pixels: "-5" or "+5"
- set width as a percentage of screen width: "25%"
- adjust width as a percentage of screen width: "-10%" or "+10%"

Pixel sizes use logical, or scaled, pixels. I.e. on an output with scale 2.0,
set-column-width "100" will make the column occupy 200 physical screen pixels.
#+begin_src kdl :tangle no :noweb-ref keybinds
Mod+Minus { set-column-width "-10%"; }
Mod+Equal { set-column-width "+10%"; }

// Finer height adjustments when in column with other windows.
Mod+Shift+Minus { set-window-height "-10%"; }
Mod+Shift+Equal { set-window-height "+10%"; }

#+end_src

#+begin_src kdl :tangle no :noweb-ref keybinds
// Move the focused window between the floating and the tiling layout.
Mod+Ctrl+V       { toggle-window-floating; }
Mod+Alt+V { switch-focus-between-floating-and-tiling; }

// Toggle tabbed column display mode.
// Windows in this column will appear as vertical tabs,
// rather than stacked on top of each other.
Mod+Tab { toggle-column-tabbed-display; }

// Actions to switch layouts.
// Note: if you uncomment these, make sure you do NOT have
// a matching layout switch hotkey configured in xkb options above.
// Having both at once on the same hotkey will break the switching,
// since it will switch twice upon pressing the hotkey (once by xkb, once by niri).
// Mod+Space       { switch-layout "next"; }
// Mod+Shift+Space { switch-layout "prev"; }

Print { screenshot; }
Ctrl+Print { screenshot-screen; }
Alt+Print { screenshot-window; }

// Applications such as remote-desktop clients and software KVM switches may
// request that niri stops processing the keyboard shortcuts defined here
// so they may, for example, forward the key presses as-is to a remote machine.
// It's a good idea to bind an escape hatch to toggle the inhibitor,
// so a buggy application can't hold your session hostage.
//
// The allow-inhibiting=false property can be applied to other binds as well,
// which ensures niri always processes them, even when an inhibitor is active.
Mod+Escape allow-inhibiting=false { toggle-keyboard-shortcuts-inhibit; }

// The quit action will show a confirmation dialog to avoid accidental exits.
Mod+Shift+E { quit; }
Ctrl+Alt+Delete { quit; }

// Powers off the monitors. To turn them back on, do any input like
// moving the mouse or pressing any other key.
Mod+Alt+Shift+P { power-off-monitors; }
#+end_src
* untangled example config
** output config
#+begin_src kdl :tangle no
output "eDP-1" {
    // Uncomment this line to disable this output.
    // off

    // Resolution and, optionally, refresh rate of the output.
    // The format is "<width>x<height>" or "<width>x<height>@<refresh rate>".
    // If the refresh rate is omitted, niri will pick the highest refresh rate
    // for the resolution.
    // If the mode is omitted altogether or is invalid, niri will pick one automatically.
    // Run `niri msg outputs` while inside a niri instance to list all outputs and their modes.
    mode "1920x1080@120.030"

    // You can use integer or fractional scale, for example use 1.5 for 150% scale.
    scale 2

    // Transform allows to rotate the output counter-clockwise, valid values are:
    // normal, 90, 180, 270, flipped, flipped-90, flipped-180 and flipped-270.
    transform "normal"

    // Position of the output in the global coordinate space.
    // This affects directional monitor actions like "focus-monitor-left", and cursor movement.
    // The cursor can only move between directly adjacent outputs.
    // Output scale and rotation has to be taken into account for positioning:
    // outputs are sized in logical, or scaled, pixels.
    // For example, a 3840Ã—2160 output with scale 2.0 will have a logical size of 1920Ã—1080,
    // so to put another output directly adjacent to it on the right, set its x to 1920.
    // If the position is unset or results in an overlap, the output is instead placed
    // automatically.
    position x=1280 y=0
}

#+end_src
** keybindings
*** using shell commands
Use =spawn-sh= to run a shell command. Do this if you need pipes, multiple commands, etc.
Note: the entire command goes as a single argument. It's passed verbatim to `sh -c`.
For example, this is a standard bind to toggle the screen reader (orca):
#+begin_src kdl :tangle no
Super+Alt+S allow-when-locked=true hotkey-overlay-title=null { spawn-sh "pkill orca || exec orca"; }
#+end_src

Example volume keys mappings for PipeWire & WirePlumber. The =allow-when-locked=true= property makes them work even when the session is locked. Using =spawn-sh= allows you to pass multiple arguments together with the command.
#+begin_src kdl :tangle no
XF86AudioRaiseVolume allow-when-locked=true { spawn-sh "wpctl set-volume @DEFAULT_AUDIO_SINK@ 0.1+"; }
XF86AudioLowerVolume allow-when-locked=true { spawn-sh "wpctl set-volume @DEFAULT_AUDIO_SINK@ 0.1-"; }
XF86AudioMute        allow-when-locked=true { spawn-sh "wpctl set-mute @DEFAULT_AUDIO_SINK@ toggle"; }
XF86AudioMicMute     allow-when-locked=true { spawn-sh "wpctl set-mute @DEFAULT_AUDIO_SOURCE@ toggle"; }
#+end_src

Example brightness key mappings for brightnessctl.
You can use regular spawn with multiple arguments too (to avoid going through "sh"),
but you need to manually put each argument in separate "" quotes.
#+begin_src kdl :tangle no
XF86MonBrightnessUp allow-when-locked=true { spawn "brightnessctl" "--class=backlight" "set" "+10%"; }
XF86MonBrightnessDown allow-when-locked=true { spawn "brightnessctl" "--class=backlight" "set" "10%-"; }
#+end_src
*** navigation alternatives
Alternative commands depending on whether you want to move across workspaces when reaching
the first or last window in a column.
#+begin_src kdl :tangle no
Mod+J     { focus-window-down; }
Mod+K     { focus-window-up; }
Mod+J     { focus-window-or-workspace-down; }
Mod+K     { focus-window-or-workspace-up; }
Mod+Ctrl+J     { move-window-down; }
Mod+Ctrl+K     { move-window-up; }
Mod+Ctrl+J     { move-window-down-or-to-workspace-down; }
Mod+Ctrl+K     { move-window-up-or-to-workspace-up; }
#+end_src
